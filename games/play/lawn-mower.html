<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <title>Cortadora de Cesped - Hospital de Dia</title>
  <link rel="icon" type="image/png" href="/favicon.png">
  <style>
    :root {
      --primary: #2563eb;
      --primary-dark: #1d4ed8;
      --secondary: #10b981;
      --background: #f8fafc;
      --surface: #ffffff;
      --text: #1e293b;
      --text-muted: #64748b;
      --border: #e2e8f0;
      --error: #ef4444;
      --success: #22c55e;
      --warning: #f59e0b;
    }

    * { margin: 0; padding: 0; box-sizing: border-box; }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
      background: var(--background);
      color: var(--text);
      line-height: 1.6;
      overflow: hidden;
      height: 100vh;
      touch-action: none;
      -webkit-user-select: none;
      user-select: none;
    }

    /* Header */
    .header {
      background: var(--surface);
      border-bottom: 2px solid var(--border);
      padding: 0.5rem 1rem;
      position: relative;
      z-index: 100;
    }
    .header-content {
      display: flex;
      align-items: center;
      justify-content: space-between;
      max-width: 1200px;
      margin: 0 auto;
      flex-wrap: wrap;
      gap: 0.4rem;
    }
    .header-left {
      display: flex;
      align-items: center;
      gap: 0.75rem;
    }
    .back-btn {
      display: inline-flex;
      align-items: center;
      gap: 0.3rem;
      padding: 0.3rem 0.7rem;
      background: var(--primary);
      color: #fff;
      border: none;
      border-radius: 8px;
      font-size: 0.85rem;
      cursor: pointer;
      text-decoration: none;
      transition: background 0.2s;
    }
    .back-btn:hover { background: var(--primary-dark); }
    .game-title {
      font-size: 1.1rem;
      font-weight: 700;
      color: var(--text);
    }
    .stats-bar {
      display: flex;
      align-items: center;
      gap: 0.7rem;
      flex-wrap: wrap;
    }
    .stat {
      display: flex;
      align-items: center;
      gap: 0.25rem;
      background: #f1f5f9;
      padding: 0.25rem 0.6rem;
      border-radius: 6px;
      font-size: 0.82rem;
      font-weight: 600;
      white-space: nowrap;
    }
    .stat-label { color: var(--text-muted); }
    .stat-value { color: var(--text); }
    .stat-score .stat-value { color: var(--primary); }
    .stat-errors .stat-value { color: var(--error); }
    .stat-bag .stat-value { color: var(--warning); }
    .stat-bag.bag-full .stat-value { color: var(--error); font-weight: 800; }

    /* Main layout */
    .game-wrapper {
      display: flex;
      flex-direction: column;
      height: calc(100vh - 52px);
    }
    .canvas-container {
      flex: 1;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 0.5rem;
      min-height: 0;
      position: relative;
    }
    canvas {
      border: 2px solid var(--border);
      border-radius: 8px;
      background: #4a7c3f;
      image-rendering: pixelated;
    }

    /* Tool button */
    /* Tool buttons container */
    .tools-container {
      position: absolute;
      top: 0.5rem;
      right: 0.5rem;
      display: flex;
      flex-direction: column;
      gap: 0.3rem;
      z-index: 10;
    }
    .tool-btn {
      padding: 0.4rem 0.8rem;
      background: var(--primary);
      color: #fff;
      border: 2px solid transparent;
      border-radius: 10px;
      font-size: 0.8rem;
      font-weight: 700;
      cursor: pointer;
      display: none;
      transition: all 0.2s;
      white-space: nowrap;
    }
    .tool-btn:hover { background: var(--primary-dark); }
    .tool-btn.active {
      background: #0891b2;
      border-color: #06b6d4;
    }
    .tool-btn.watering-active {
      background: #059669;
      border-color: #10b981;
    }
    .tool-indicator {
      position: absolute;
      top: 0.5rem;
      left: 0.5rem;
      padding: 0.3rem 0.6rem;
      background: rgba(0,0,0,0.7);
      color: #fff;
      border-radius: 8px;
      font-size: 0.75rem;
      font-weight: 600;
      z-index: 10;
      display: none;
    }

    /* Mobile D-Pad */
    .dpad-container {
      display: none;
      justify-content: center;
      padding: 0.3rem 0 0.6rem 0;
    }
    .dpad {
      display: grid;
      grid-template-areas:
        ".    up   ."
        "left mid  right"
        ".    down .";
      grid-template-columns: 60px 60px 60px;
      grid-template-rows: 60px 60px 60px;
      gap: 4px;
    }
    .dpad-btn {
      background: var(--primary);
      color: #fff;
      border: none;
      border-radius: 12px;
      font-size: 1.6rem;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: background 0.1s;
      -webkit-tap-highlight-color: transparent;
      touch-action: manipulation;
      -webkit-user-select: none;
      user-select: none;
    }
    .dpad-btn:active { background: var(--primary-dark); transform: scale(0.93); }
    .dpad-up { grid-area: up; }
    .dpad-down { grid-area: down; }
    .dpad-left { grid-area: left; }
    .dpad-right { grid-area: right; }

    /* Level Select Screen */
    .screen-overlay {
      position: fixed;
      inset: 0;
      background: rgba(15,23,42,0.6);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 200;
      padding: 1rem;
    }
    .screen-overlay.hidden { display: none; }
    .screen-card {
      background: var(--surface);
      border-radius: 16px;
      padding: 2rem;
      max-width: 480px;
      width: 100%;
      box-shadow: 0 20px 60px rgba(0,0,0,0.3);
      max-height: 90vh;
      overflow-y: auto;
    }
    .screen-card h1 {
      font-size: 1.6rem;
      text-align: center;
      margin-bottom: 0.3rem;
      color: var(--text);
    }
    .screen-card .subtitle {
      text-align: center;
      color: var(--text-muted);
      font-size: 0.95rem;
      margin-bottom: 1.5rem;
    }
    .level-list {
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
    }
    .level-btn {
      display: flex;
      align-items: center;
      gap: 0.75rem;
      padding: 0.8rem 1rem;
      background: #f1f5f9;
      border: 2px solid var(--border);
      border-radius: 12px;
      cursor: pointer;
      transition: all 0.2s;
      text-align: left;
      font-size: 0.95rem;
    }
    .level-btn:hover { border-color: var(--primary); background: #eff6ff; }
    .level-num {
      width: 36px; height: 36px;
      background: var(--primary);
      color: #fff;
      border-radius: 10px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-weight: 800;
      font-size: 1.1rem;
      flex-shrink: 0;
    }
    .level-info { flex: 1; }
    .level-name { font-weight: 700; color: var(--text); }
    .level-desc { font-size: 0.8rem; color: var(--text-muted); }

    /* Result modal */
    .result-title {
      font-size: 1.5rem;
      text-align: center;
      margin-bottom: 1rem;
    }
    .result-title.win { color: var(--success); }
    .result-title.lose { color: var(--error); }
    .score-breakdown {
      display: flex;
      flex-direction: column;
      gap: 0.4rem;
      margin-bottom: 1.5rem;
    }
    .score-row {
      display: flex;
      justify-content: space-between;
      padding: 0.3rem 0;
      font-size: 0.95rem;
    }
    .score-row.total {
      border-top: 2px solid var(--border);
      padding-top: 0.6rem;
      margin-top: 0.3rem;
      font-weight: 800;
      font-size: 1.1rem;
    }
    .score-row .pts { font-weight: 700; }
    .pts.positive { color: var(--success); }
    .pts.negative { color: var(--error); }
    .result-actions {
      display: flex;
      gap: 0.5rem;
      justify-content: center;
      flex-wrap: wrap;
    }
    .btn-primary {
      padding: 0.6rem 1.4rem;
      background: var(--primary);
      color: #fff;
      border: none;
      border-radius: 10px;
      font-size: 1rem;
      font-weight: 600;
      cursor: pointer;
      transition: background 0.2s;
    }
    .btn-primary:hover { background: var(--primary-dark); }
    .btn-secondary {
      padding: 0.6rem 1.4rem;
      background: #e2e8f0;
      color: var(--text);
      border: none;
      border-radius: 10px;
      font-size: 1rem;
      font-weight: 600;
      cursor: pointer;
      transition: background 0.2s;
    }
    .btn-secondary:hover { background: #cbd5e1; }

    /* Toast messages */
    .toast {
      position: fixed;
      top: 60px;
      left: 50%;
      transform: translateX(-50%) translateY(-20px);
      background: var(--text);
      color: #fff;
      padding: 0.6rem 1.2rem;
      border-radius: 10px;
      font-weight: 600;
      font-size: 0.95rem;
      z-index: 300;
      opacity: 0;
      transition: all 0.3s;
      pointer-events: none;
      white-space: nowrap;
    }
    .toast.show { opacity: 1; transform: translateX(-50%) translateY(0); }
    .toast.error { background: var(--error); }
    .toast.warn { background: var(--warning); color: var(--text); }
    .toast.info { background: var(--primary); }

    /* Stuck overlay */
    .stuck-overlay {
      position: absolute;
      inset: 0;
      background: rgba(239,68,68,0.15);
      display: flex;
      align-items: center;
      justify-content: center;
      border-radius: 8px;
      z-index: 50;
      pointer-events: none;
    }
    .stuck-overlay.hidden { display: none; }
    .stuck-text {
      background: var(--error);
      color: #fff;
      padding: 0.5rem 1.2rem;
      border-radius: 10px;
      font-weight: 700;
      font-size: 1.1rem;
      animation: pulse 0.5s ease-in-out infinite alternate;
    }
    @keyframes pulse { from { transform: scale(1); } to { transform: scale(1.05); } }

    /* Celebration particles */
    .celebration {
      position: fixed;
      inset: 0;
      pointer-events: none;
      z-index: 250;
    }
    .celebration.hidden { display: none; }

    /* Restart button in header */
    .restart-btn {
      display: none;
      align-items: center;
      gap: 0.3rem;
      padding: 0.3rem 0.7rem;
      background: var(--warning);
      color: #fff;
      border: none;
      border-radius: 8px;
      font-size: 0.85rem;
      font-weight: 600;
      cursor: pointer;
      transition: background 0.2s;
    }
    .restart-btn:hover { background: #d97706; }
    .restart-btn.visible { display: inline-flex; }

    /* Next level button (green) */
    .btn-next {
      padding: 0.6rem 1.4rem;
      background: var(--success);
      color: #fff;
      border: none;
      border-radius: 10px;
      font-size: 1rem;
      font-weight: 700;
      cursor: pointer;
      transition: background 0.2s;
      animation: glowPulse 1.5s ease-in-out infinite alternate;
    }
    .btn-next:hover { background: #16a34a; }
    @keyframes glowPulse { from { box-shadow: 0 0 5px rgba(34,197,94,0.3); } to { box-shadow: 0 0 20px rgba(34,197,94,0.6); } }

    /* Instruction popup */
    .instruction-overlay {
      position: fixed;
      inset: 0;
      background: rgba(15,23,42,0.7);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 210;
      padding: 1rem;
    }
    .instruction-overlay.hidden { display: none; }
    .instruction-card {
      background: var(--surface);
      border-radius: 16px;
      padding: 1.5rem 2rem;
      max-width: 440px;
      width: 100%;
      box-shadow: 0 20px 60px rgba(0,0,0,0.3);
      text-align: center;
    }
    .instruction-card h2 {
      font-size: 1.3rem;
      margin-bottom: 0.8rem;
      color: var(--primary);
    }
    .instruction-card .tip-list {
      text-align: left;
      margin: 0.8rem 0;
      font-size: 0.9rem;
      line-height: 1.7;
      color: var(--text);
    }
    .instruction-card .tip-list li {
      margin-bottom: 0.3rem;
    }
    .instruction-card .btn-start {
      padding: 0.7rem 2rem;
      background: var(--success);
      color: #fff;
      border: none;
      border-radius: 10px;
      font-size: 1.1rem;
      font-weight: 700;
      cursor: pointer;
      margin-top: 0.8rem;
      transition: background 0.2s;
    }
    .instruction-card .btn-start:hover { background: #16a34a; }

    /* Blocked/stuck detection overlay */
    .blocked-overlay {
      position: absolute;
      inset: 0;
      background: rgba(239,68,68,0.2);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      border-radius: 8px;
      z-index: 55;
      gap: 0.8rem;
    }
    .blocked-overlay.hidden { display: none; }
    .blocked-text {
      background: var(--error);
      color: #fff;
      padding: 0.6rem 1.4rem;
      border-radius: 10px;
      font-weight: 700;
      font-size: 1rem;
      text-align: center;
      line-height: 1.4;
    }
    .blocked-restart-btn {
      padding: 0.5rem 1.2rem;
      background: var(--warning);
      color: #fff;
      border: none;
      border-radius: 10px;
      font-weight: 700;
      font-size: 0.95rem;
      cursor: pointer;
      pointer-events: auto;
    }

    /* Metrics panel */
    .metrics-overlay {
      position: fixed;
      inset: 0;
      background: rgba(15,23,42,0.7);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 220;
      padding: 1rem;
    }
    .metrics-overlay.hidden { display: none; }
    .metrics-card {
      background: var(--surface);
      border-radius: 16px;
      padding: 1.5rem;
      max-width: 700px;
      width: 100%;
      box-shadow: 0 20px 60px rgba(0,0,0,0.3);
      max-height: 90vh;
      overflow-y: auto;
    }
    .metrics-card h2 {
      font-size: 1.2rem;
      text-align: center;
      margin-bottom: 1rem;
      color: var(--primary);
    }
    .metrics-charts {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 1rem;
    }
    @media (max-width: 600px) {
      .metrics-charts { grid-template-columns: 1fr; }
    }
    .chart-container {
      background: #f8fafc;
      border: 1px solid var(--border);
      border-radius: 10px;
      padding: 0.8rem;
    }
    .chart-container h3 {
      font-size: 0.85rem;
      color: var(--text-muted);
      margin-bottom: 0.5rem;
      text-align: center;
    }
    .chart-container canvas {
      width: 100% !important;
      height: 150px !important;
      border: none;
      border-radius: 4px;
      background: #fff;
      image-rendering: auto;
    }
    .metrics-close-btn {
      display: block;
      margin: 1rem auto 0;
      padding: 0.5rem 1.5rem;
      background: var(--primary);
      color: #fff;
      border: none;
      border-radius: 10px;
      font-size: 0.95rem;
      font-weight: 600;
      cursor: pointer;
    }
    .btn-metrics {
      padding: 0.6rem 1.4rem;
      background: #7c3aed;
      color: #fff;
      border: none;
      border-radius: 10px;
      font-size: 0.9rem;
      font-weight: 600;
      cursor: pointer;
      transition: background 0.2s;
    }
    .btn-metrics:hover { background: #6d28d9; }

    /* Responsive */
    @media (max-width: 700px) {
      .dpad-container { display: flex; }
      .game-title { font-size: 0.9rem; }
      .stat { font-size: 0.75rem; padding: 0.2rem 0.4rem; }
      .header { padding: 0.4rem 0.6rem; }
      .screen-card { padding: 1.2rem; }
      .screen-card h1 { font-size: 1.3rem; }
      .restart-btn { font-size: 0.75rem; padding: 0.2rem 0.5rem; }
    }
    @media (pointer: coarse) {
      .dpad-container { display: flex; }
    }
  </style>
</head>
<body>

  <!-- Header -->
  <div class="header">
    <div class="header-content">
      <div class="header-left">
        <a href="/games/portal" class="back-btn" id="backBtn">&#8592; Volver</a>
        <span class="game-title" id="gameTitle">Cortadora de Cesped</span>
        <span class="demo-badge" id="demoBadge" style="display:none; background:#f59e0b; color:#fff; padding:0.2rem 0.5rem; border-radius:4px; font-size:0.75rem; font-weight:600;">MODO DEMO</span>
        <button class="restart-btn" id="restartBtn" title="Reiniciar nivel">&#8635; Reiniciar</button>
      </div>
      <div class="stats-bar" id="statsBar">
        <div class="stat stat-score">
          <span class="stat-label">Puntos:</span>
          <span class="stat-value" id="scoreDisplay">0</span>
        </div>
        <div class="stat stat-errors">
          <span class="stat-label">Errores:</span>
          <span class="stat-value" id="errorsDisplay">0</span>
        </div>
        <div class="stat">
          <span class="stat-label">Cesped:</span>
          <span class="stat-value" id="grassDisplay">0/0</span>
        </div>
        <div class="stat stat-bag" id="bagStat" style="display:none;">
          <span class="stat-label">Bolsa:</span>
          <span class="stat-value" id="bagDisplay">0/15</span>
        </div>
        <div class="stat">
          <span class="stat-label">Tiempo:</span>
          <span class="stat-value" id="timerDisplay">0:00</span>
        </div>
      </div>
    </div>
  </div>

  <!-- Game area -->
  <div class="game-wrapper">
    <div class="canvas-container" id="canvasContainer">
      <canvas id="gameCanvas"></canvas>
      <div class="tools-container">
        <button class="tool-btn" id="toolBtn">Limpiador de Piscina</button>
        <button class="tool-btn" id="waterBtn">Regadera</button>
      </div>
      <div class="tool-indicator" id="toolIndicator">Cortadora</div>
      <div class="stuck-overlay hidden" id="stuckOverlay">
        <div class="stuck-text">Atascado en cable!</div>
      </div>
      <div class="blocked-overlay hidden" id="blockedOverlay">
        <div class="blocked-text">Te bloqueaste! No hay cesped alcanzable.</div>
        <button class="blocked-restart-btn" id="blockedRestartBtn">Reiniciar Nivel</button>
      </div>
    </div>
    <div class="dpad-container">
      <div class="dpad">
        <button class="dpad-btn dpad-up" data-dir="up">&#9650;</button>
        <button class="dpad-btn dpad-left" data-dir="left">&#9664;</button>
        <button class="dpad-btn dpad-right" data-dir="right">&#9654;</button>
        <button class="dpad-btn dpad-down" data-dir="down">&#9660;</button>
      </div>
    </div>
  </div>

  <!-- Toast -->
  <div class="toast" id="toast"></div>

  <!-- Celebration canvas -->
  <canvas class="celebration hidden" id="celebrationCanvas"></canvas>

  <!-- Level Select Overlay -->
  <div class="screen-overlay" id="levelSelectScreen">
    <div class="screen-card" style="max-height: 90vh; overflow-y: auto;">
      <h1>Cortadora de Cesped</h1>
      <p class="subtitle">Corta todo el cesped del jardin sin da침ar las flores ni caer en la piscina.</p>
      <p class="subtitle" style="font-size:0.8rem; margin-top:0.5rem; opacity:0.8;">Controles: Flechas/WASD, D-Pad tactil, o arrastra con click derecho del mouse.</p>
      <div class="level-list">
        <button class="level-btn" data-level="1">
          <div class="level-num">1</div>
          <div class="level-info">
            <div class="level-name">Tutorial</div>
            <div class="level-desc">Jardin pequeno para aprender los controles.</div>
          </div>
        </button>
        <button class="level-btn" data-level="2">
          <div class="level-num">2</div>
          <div class="level-info">
            <div class="level-name">Jardin Simple</div>
            <div class="level-desc">Jardin rectangular con algunas flores.</div>
          </div>
        </button>
        <button class="level-btn" data-level="3">
          <div class="level-num">3</div>
          <div class="level-info">
            <div class="level-name">Mas Flores</div>
            <div class="level-desc">Mayor cantidad de flores para esquivar.</div>
          </div>
        </button>
        <button class="level-btn" data-level="4">
          <div class="level-num">4</div>
          <div class="level-info">
            <div class="level-name">Primera Piscina</div>
            <div class="level-desc">Introduccion a la piscina como obstaculo.</div>
          </div>
        </button>
        <button class="level-btn" data-level="5">
          <div class="level-num">5</div>
          <div class="level-info">
            <div class="level-name">Piscina Grande</div>
            <div class="level-desc">Zona de piscina mas amplia.</div>
          </div>
        </button>
        <button class="level-btn" data-level="6">
          <div class="level-num">6</div>
          <div class="level-info">
            <div class="level-name">Cables Peligrosos</div>
            <div class="level-desc">Cables en el suelo que debes recoger.</div>
          </div>
        </button>
        <button class="level-btn" data-level="7">
          <div class="level-num">7</div>
          <div class="level-info">
            <div class="level-name">Jardin en L</div>
            <div class="level-desc">Forma de L con cables y piscina.</div>
          </div>
        </button>
        <button class="level-btn" data-level="8">
          <div class="level-num">8</div>
          <div class="level-info">
            <div class="level-name">La Compostera</div>
            <div class="level-desc">Bolsa con capacidad limitada, usa la compostera.</div>
          </div>
        </button>
        <button class="level-btn" data-level="9">
          <div class="level-num">9</div>
          <div class="level-info">
            <div class="level-name">Camino Sinuoso</div>
            <div class="level-desc">Jardin con caminos y obstaculos mixtos.</div>
          </div>
        </button>
        <button class="level-btn" data-level="10">
          <div class="level-num">10</div>
          <div class="level-info">
            <div class="level-name">Limpieza de Piscina</div>
            <div class="level-desc">Usa el limpiador de piscina para limpiar el agua sucia.</div>
          </div>
        </button>
        <button class="level-btn" data-level="11">
          <div class="level-num">11</div>
          <div class="level-info">
            <div class="level-name">Jardin Doble</div>
            <div class="level-desc">Dos zonas de jardin conectadas.</div>
          </div>
        </button>
        <button class="level-btn" data-level="12">
          <div class="level-num">12</div>
          <div class="level-info">
            <div class="level-name">Pasajes Estrechos</div>
            <div class="level-desc">Caminos angostos entre obstaculos.</div>
          </div>
        </button>
        <button class="level-btn" data-level="13">
          <div class="level-num">13</div>
          <div class="level-info">
            <div class="level-name">Laberinto</div>
            <div class="level-desc">Jardin tipo laberinto con muchos cables.</div>
          </div>
        </button>
        <button class="level-btn" data-level="14">
          <div class="level-num">14</div>
          <div class="level-info">
            <div class="level-name">Zona de Piscinas</div>
            <div class="level-desc">Gran area de piscina sucia para limpiar.</div>
          </div>
        </button>
        <button class="level-btn" data-level="15">
          <div class="level-num">15</div>
          <div class="level-info">
            <div class="level-name">Jardin en U</div>
            <div class="level-desc">Jardin con forma de U y multiples zonas.</div>
          </div>
        </button>
        <button class="level-btn" data-level="16">
          <div class="level-num">16</div>
          <div class="level-info">
            <div class="level-name">Multizona</div>
            <div class="level-desc">Jardin complejo con multiples secciones.</div>
          </div>
        </button>
        <button class="level-btn" data-level="17">
          <div class="level-num">17</div>
          <div class="level-info">
            <div class="level-name">Zonas Aisladas</div>
            <div class="level-desc">Muchas zonas separadas conectadas por caminos.</div>
          </div>
        </button>
        <button class="level-btn" data-level="18">
          <div class="level-num">18</div>
          <div class="level-info">
            <div class="level-name">Experto</div>
            <div class="level-desc">Todos los obstaculos en cantidad.</div>
          </div>
        </button>
        <button class="level-btn" data-level="19">
          <div class="level-num">19</div>
          <div class="level-info">
            <div class="level-name">Prueba de Maestria</div>
            <div class="level-desc">Jardin extenso con maxima dificultad.</div>
          </div>
        </button>
        <button class="level-btn" data-level="20">
          <div class="level-num">20</div>
          <div class="level-info">
            <div class="level-name">Gran Maestro</div>
            <div class="level-desc">El desafio final. Enorme jardin con todos los elementos.</div>
          </div>
        </button>

        <!-- ESCALA 2: Niveles 21-40 (cuadros m치s peque침os) -->
        <div style="margin-top: 1.5rem; padding-top: 1rem; border-top: 2px solid var(--border);">
          <h3 style="text-align:center; color:var(--primary); margin-bottom:0.5rem;">Escala 2 - Cuadros Peque침os</h3>
          <p style="text-align:center; font-size:0.8rem; color:var(--text-muted); margin-bottom:1rem;">Los mismos niveles con grilla m치s densa</p>
        </div>
        <button class="level-btn" data-level="21">
          <div class="level-num" style="background:#0891b2;">21</div>
          <div class="level-info">
            <div class="level-name">Tutorial (Escala 2)</div>
            <div class="level-desc">Jardin pequeno con cuadros mas finos.</div>
          </div>
        </button>
        <button class="level-btn" data-level="25">
          <div class="level-num" style="background:#0891b2;">25</div>
          <div class="level-info">
            <div class="level-name">Piscina Grande (Escala 2)</div>
            <div class="level-desc">Zona de piscina amplia con precision aumentada.</div>
          </div>
        </button>
        <button class="level-btn" data-level="30">
          <div class="level-num" style="background:#0891b2;">30</div>
          <div class="level-info">
            <div class="level-name">Limpieza de Piscina (Escala 2)</div>
            <div class="level-desc">Nivel de limpieza con mayor detalle.</div>
          </div>
        </button>
        <button class="level-btn" data-level="40">
          <div class="level-num" style="background:#0891b2;">40</div>
          <div class="level-info">
            <div class="level-name">Gran Maestro (Escala 2)</div>
            <div class="level-desc">El desafio final con cuadros peque침os.</div>
          </div>
        </button>

        <!-- ESCALA 3: Niveles 41-60 (cuadros muy peque침os) -->
        <div style="margin-top: 1.5rem; padding-top: 1rem; border-top: 2px solid var(--border);">
          <h3 style="text-align:center; color:#7c3aed; margin-bottom:0.5rem;">Escala 3 - Cuadros Mini</h3>
          <p style="text-align:center; font-size:0.8rem; color:var(--text-muted); margin-bottom:1rem;">Maxima precision con grilla muy densa</p>
        </div>
        <button class="level-btn" data-level="41">
          <div class="level-num" style="background:#7c3aed;">41</div>
          <div class="level-info">
            <div class="level-name">Tutorial (Escala 3)</div>
            <div class="level-desc">Jardin con cuadros mini para expertos.</div>
          </div>
        </button>
        <button class="level-btn" data-level="50">
          <div class="level-num" style="background:#7c3aed;">50</div>
          <div class="level-info">
            <div class="level-name">Limpieza de Piscina (Escala 3)</div>
            <div class="level-desc">Precision extrema en limpieza.</div>
          </div>
        </button>
        <button class="level-btn" data-level="60">
          <div class="level-num" style="background:#7c3aed;">60</div>
          <div class="level-info">
            <div class="level-name">Gran Maestro (Escala 3)</div>
            <div class="level-desc">El desafio definitivo. Cuadros diminutos.</div>
          </div>
        </button>

        <!-- PARTE 2: Mantenimiento Completo -->
        <div style="margin-top: 1.5rem; padding-top: 1rem; border-top: 3px solid var(--success);">
          <h3 style="text-align:center; color:var(--success); margin-bottom:0.5rem;">游 PARTE 2: Jardinero Completo 游</h3>
          <p style="text-align:center; font-size:0.8rem; color:var(--text-muted); margin-bottom:1rem;">Pileta, cesped y flores con 3 herramientas</p>
        </div>
        <button class="level-btn" data-level="101">
          <div class="level-num" style="background:#10b981;">P2-1</div>
          <div class="level-info">
            <div class="level-name">Jardin Abandonado</div>
            <div class="level-desc">Aprende las 3 herramientas: Cortadora, Limpiador y Regadera.</div>
          </div>
        </button>
        <button class="level-btn" data-level="102">
          <div class="level-num" style="background:#10b981;">P2-2</div>
          <div class="level-info">
            <div class="level-name">Rescate del Jardin</div>
            <div class="level-desc">Flores marchitas necesitan agua, cesped alto y piscina sucia.</div>
          </div>
        </button>
        <button class="level-btn" data-level="103">
          <div class="level-num" style="background:#10b981;">P2-3</div>
          <div class="level-info">
            <div class="level-name">Mansion Descuidada</div>
            <div class="level-desc">Gran jardin con todas las tareas de mantenimiento.</div>
          </div>
        </button>
        <button class="level-btn" data-level="104">
          <div class="level-num" style="background:#10b981;">P2-4</div>
          <div class="level-info">
            <div class="level-name">Hotel de Lujo</div>
            <div class="level-desc">Multiple areas de jardin con piscinas y jardines florales.</div>
          </div>
        </button>
        <button class="level-btn" data-level="105">
          <div class="level-num" style="background:#10b981;">P2-5</div>
          <div class="level-info">
            <div class="level-name">Parque Municipal</div>
            <div class="level-desc">El desafio final de mantenimiento completo.</div>
          </div>
        </button>
      </div>
    </div>
  </div>

  <!-- Result Overlay -->
  <div class="screen-overlay hidden" id="resultScreen">
    <div class="screen-card">
      <h1 class="result-title" id="resultTitle"></h1>
      <div class="score-breakdown" id="scoreBreakdown"></div>
      <div class="result-actions">
        <button class="btn-next hidden" id="nextLevelBtn">Siguiente Nivel &#8594;</button>
        <button class="btn-primary" id="retryBtn">Reintentar</button>
        <button class="btn-metrics" id="metricsBtn">Biomarcadores</button>
        <button class="btn-secondary" id="levelsBtn">Niveles</button>
        <a href="/games/portal" class="btn-secondary" style="text-decoration:none;">Volver al portal</a>
      </div>
    </div>
  </div>

  <!-- Instruction Overlay -->
  <div class="instruction-overlay hidden" id="instructionOverlay">
    <div class="instruction-card">
      <h2 id="instructionTitle">Instrucciones</h2>
      <ul class="tip-list" id="instructionTips"></ul>
      <button class="btn-start" id="instructionStartBtn">Comenzar!</button>
    </div>
  </div>

  <!-- Metrics Overlay -->
  <div class="metrics-overlay hidden" id="metricsOverlay">
    <div class="metrics-card">
      <h2>Biomarcadores Clinicos - Metricas en Tiempo Real</h2>
      <div class="metrics-charts" id="metricsCharts"></div>
      <button class="metrics-close-btn" id="metricsCloseBtn">Cerrar</button>
    </div>
  </div>

<script>
(function() {
  'use strict';

  // ---- TILE TYPES ----
  const T = {
    GRASS: 0,
    CUT: 1,
    FLOWER: 2,
    POOL: 3,
    PATH: 4,
    CABLE: 5,
    COMPOST: 6,
    HOUSE: 7,
    FENCE: 8,
    POOL_DIRTY: 9, // for level 5 pool cleaning section
    EMPTY: 10,      // outside yard
    FLOWER_DRY: 11, // flowers that need watering (Part 2)
    FLOWER_WATERED: 12 // watered flowers (Part 2)
  };

  // ---- COLORS ----
  const TILE_COLORS = {
    [T.GRASS]:      '#4ade80',
    [T.CUT]:        '#bbf7d0',
    [T.FLOWER]:     '#4ade80', // drawn with flower on top
    [T.POOL]:       '#38bdf8',
    [T.PATH]:       '#d1d5db',
    [T.CABLE]:      '#4ade80', // drawn with cable on top
    [T.COMPOST]:    '#92400e',
    [T.HOUSE]:      '#a1887f',
    [T.FENCE]:      '#475569',
    [T.POOL_DIRTY]: '#67e8f9',
    [T.EMPTY]:      '#e2e8f0',
    [T.FLOWER_DRY]: '#d4a574', // brownish for dry ground
    [T.FLOWER_WATERED]: '#4ade80' // back to green when watered
  };

  // Flower colors palette
  const FLOWER_PALETTE = ['#f43f5e','#ec4899','#a855f7','#eab308','#f97316','#e879f9'];

  // ---- STATE ----
  let currentLevel = 1;
  let grid = [];
  let gridW = 0, gridH = 0;
  let playerX = 0, playerY = 0;
  let score = 0;
  let errors = 0;
  let flowersHit = 0;
  let poolHits = 0;
  let cableStucks = 0;
  let grassCut = 0;
  let totalGrass = 0;
  let bagCount = 0;
  let bagCapacity = 15;
  let bagEmptyCount = 0;
  let hasBag = false;
  let isStuck = false;
  let stuckTimer = null;
  let timerSeconds = 0;
  let timerInterval = null;
  let gameRunning = false;
  let gameSessionId = null;
  let startTime = 0;
  let collectedCables = new Set();
  let flowerColors = {};
  let usingPoolCleaner = false;
  let hasPoolCleaner = false;
  let poolCleaningRequired = false;
  let usingWateringCan = false;
  let hasWateringCan = false;
  let wateringRequired = false;
  let flowersWatered = 0;
  let totalDryFlowers = 0;
  let currentScale = 1; // 1 = normal, 2 = small squares, 3 = mini squares
  let isPart2 = false;
  let isBlocked = false;
  let blockedCheckInterval = null;

  // ---- CONTINUOUS METRICS TIME SERIES (FDA Biomarkers) ----
  let metricsTimeSeries = {
    timestamps: [],       // seconds since start
    cumulativeGrassCut: [],
    cumulativeErrors: [],
    cumulativeScore: [],
    reactionTimesOverTime: [], // RT at each grass cut
    movementEfficiency: [],    // running efficiency ratio
    pauseEvents: [],           // {time, duration}
    commissionEvents: [],      // {time, type: 'flower'|'pool'|'cable'}
    bagFullEvents: [],         // {time}
  };

  function resetMetricsTimeSeries() {
    metricsTimeSeries = {
      timestamps: [],
      cumulativeGrassCut: [],
      cumulativeErrors: [],
      cumulativeScore: [],
      reactionTimesOverTime: [],
      movementEfficiency: [],
      pauseEvents: [],
      commissionEvents: [],
      bagFullEvents: [],
    };
  }

  function recordTimeSeriesPoint() {
    if (!gameRunning) return;
    const elapsed = Math.floor((Date.now() - startTime) / 1000);
    metricsTimeSeries.timestamps.push(elapsed);
    metricsTimeSeries.cumulativeGrassCut.push(grassCut);
    metricsTimeSeries.cumulativeErrors.push(errors);
    metricsTimeSeries.cumulativeScore.push(score);
    metricsTimeSeries.movementEfficiency.push(
      clinicalMetrics.totalMoves > 0 ? (clinicalMetrics.successfulMoves / clinicalMetrics.totalMoves) : 1
    );
  }

  // ---- CLINICAL BIOMARKERS (Digital Phenotyping) ----
  // For ADHD/attention assessment (EndeavorRx-style metrics)
  let clinicalMetrics = {
    // Reaction Time Variability (RTV) - key ADHD marker
    reactionTimes: [],       // Array of times (ms) between each grass cut
    lastGrassCutTime: 0,     // Timestamp of last grass cut

    // Movement Analysis
    totalMoves: 0,           // Total movement commands issued
    successfulMoves: 0,      // Moves that resulted in position change
    invalidMoves: 0,         // Moves blocked by obstacles
    totalDistanceTraveled: 0, // Manhattan distance traveled
    movementPath: [],        // Array of {x, y, timestamp}

    // Omission Errors (inattention) - grass left uncut when time runs out or quit
    // Calculated at end: (totalGrass - grassCut) when not completed

    // Commission Errors (impulsivity) - already tracked as flowersHit, poolHits
    // These represent "Go/No-Go" task failures

    // Hesitation/Pause patterns
    pauseDurations: [],      // Times (ms) with no input
    lastInputTime: 0,        // For detecting pauses

    // Device context
    inputMethod: 'unknown',  // 'keyboard', 'touch', 'mouse'
    frameRateReadings: [],   // To detect lag issues
    lastFrameTime: 0,

    // Session timing
    sessionStartTime: 0,
    firstMoveTime: 0,        // Time to first action (reaction to start)
    levelCompletionAttempts: 0  // How many times level was restarted
  };

  function resetClinicalMetrics() {
    clinicalMetrics = {
      reactionTimes: [],
      lastGrassCutTime: 0,
      totalMoves: 0,
      successfulMoves: 0,
      invalidMoves: 0,
      totalDistanceTraveled: 0,
      movementPath: [],
      pauseDurations: [],
      lastInputTime: Date.now(),
      inputMethod: clinicalMetrics.inputMethod || 'unknown',
      frameRateReadings: [],
      lastFrameTime: 0,
      sessionStartTime: Date.now(),
      firstMoveTime: 0,
      levelCompletionAttempts: clinicalMetrics.levelCompletionAttempts + 1
    };
  }

  // Calculate clinical statistics
  function calculateClinicalStats() {
    const stats = {
      session_summary: {
        total_duration_sec: Math.floor((Date.now() - startTime) / 1000),
        accuracy_percentage: totalGrass > 0 ? Math.round((grassCut / totalGrass) * 100) : 0,
        level_reached: currentLevel
      },
      clinical_markers: {
        // Reaction Time Variability (key ADHD biomarker)
        mean_reaction_time_ms: 0,
        rt_variability_sd: 0,
        rt_coefficient_of_variation: 0,  // CV = SD/Mean - normalized variability

        // Omission errors (inattention) - stimuli ignored
        omission_errors: totalGrass - grassCut,
        omission_rate: totalGrass > 0 ? ((totalGrass - grassCut) / totalGrass) : 0,

        // Commission errors (impulsivity) - wrong actions taken
        commission_errors: flowersHit + poolHits,
        impulsivity_ratio: clinicalMetrics.totalMoves > 0
          ? ((flowersHit + poolHits) / clinicalMetrics.totalMoves) : 0,

        // Detailed commission breakdown
        flowers_destroyed: flowersHit,
        pool_falls: poolHits,
        cable_stucks: cableStucks,

        // Movement efficiency (planning/executive function)
        movement_efficiency: clinicalMetrics.totalMoves > 0
          ? (clinicalMetrics.successfulMoves / clinicalMetrics.totalMoves) : 0,
        invalid_move_attempts: clinicalMetrics.invalidMoves,

        // Visuomotor efficiency (distance traveled vs optimal path)
        total_distance_traveled: clinicalMetrics.totalDistanceTraveled,
        path_efficiency: (clinicalMetrics.totalDistanceTraveled > 0 && totalGrass > 0)
          ? Math.min(1, totalGrass / clinicalMetrics.totalDistanceTraveled) : 0,

        // Hesitation analysis (may indicate uncertainty or fatigue)
        avg_pause_duration_ms: 0,
        long_pauses_count: 0,  // pauses > 3 seconds

        // Time to first action (initial reaction)
        time_to_first_action_ms: clinicalMetrics.firstMoveTime > 0
          ? (clinicalMetrics.firstMoveTime - clinicalMetrics.sessionStartTime) : 0
      },
      device_context: {
        input_method: clinicalMetrics.inputMethod,
        frame_rate_avg: 0,
        session_restarts: clinicalMetrics.levelCompletionAttempts - 1
      }
    };

    // Calculate Reaction Time statistics
    if (clinicalMetrics.reactionTimes.length > 1) {
      const rts = clinicalMetrics.reactionTimes;
      const sum = rts.reduce((a, b) => a + b, 0);
      const mean = sum / rts.length;
      const squaredDiffs = rts.map(rt => Math.pow(rt - mean, 2));
      const variance = squaredDiffs.reduce((a, b) => a + b, 0) / rts.length;
      const sd = Math.sqrt(variance);

      stats.clinical_markers.mean_reaction_time_ms = Math.round(mean);
      stats.clinical_markers.rt_variability_sd = Math.round(sd);
      stats.clinical_markers.rt_coefficient_of_variation = mean > 0 ? (sd / mean) : 0;
    }

    // Calculate pause statistics
    if (clinicalMetrics.pauseDurations.length > 0) {
      const pauses = clinicalMetrics.pauseDurations;
      stats.clinical_markers.avg_pause_duration_ms =
        Math.round(pauses.reduce((a, b) => a + b, 0) / pauses.length);
      stats.clinical_markers.long_pauses_count = pauses.filter(p => p > 3000).length;
    }

    // Calculate frame rate average
    if (clinicalMetrics.frameRateReadings.length > 0) {
      const frs = clinicalMetrics.frameRateReadings;
      stats.device_context.frame_rate_avg =
        Math.round(frs.reduce((a, b) => a + b, 0) / frs.length);
    }

    return stats;
  }

  // Track input method
  function recordInputMethod(method) {
    if (clinicalMetrics.inputMethod === 'unknown') {
      clinicalMetrics.inputMethod = method;
    }
  }

  // Record movement for clinical analysis
  function recordMovement(dx, dy, successful, timestamp) {
    clinicalMetrics.totalMoves++;

    if (successful) {
      clinicalMetrics.successfulMoves++;
      clinicalMetrics.totalDistanceTraveled += Math.abs(dx) + Math.abs(dy);
      clinicalMetrics.movementPath.push({
        x: playerX,
        y: playerY,
        timestamp: timestamp
      });
    } else {
      clinicalMetrics.invalidMoves++;
    }

    // Track pauses (time since last input)
    const pauseDuration = timestamp - clinicalMetrics.lastInputTime;
    if (pauseDuration > 500) { // Only record pauses > 500ms
      clinicalMetrics.pauseDurations.push(pauseDuration);
      metricsTimeSeries.pauseEvents.push({ time: Math.floor((timestamp - startTime) / 1000), duration: pauseDuration });
    }
    clinicalMetrics.lastInputTime = timestamp;

    // Record first move time
    if (clinicalMetrics.firstMoveTime === 0) {
      clinicalMetrics.firstMoveTime = timestamp;
    }
  }

  // Record grass cut timing for RTV calculation
  function recordGrassCut() {
    const now = Date.now();
    if (clinicalMetrics.lastGrassCutTime > 0) {
      const reactionTime = now - clinicalMetrics.lastGrassCutTime;
      // Only record reasonable reaction times (50ms - 10s)
      if (reactionTime >= 50 && reactionTime <= 10000) {
        clinicalMetrics.reactionTimes.push(reactionTime);
        metricsTimeSeries.reactionTimesOverTime.push(reactionTime);
      }
    }
    clinicalMetrics.lastGrassCutTime = now;
  }

  // Frame rate monitoring (for device context)
  function recordFrameRate() {
    const now = performance.now();
    if (clinicalMetrics.lastFrameTime > 0) {
      const delta = now - clinicalMetrics.lastFrameTime;
      if (delta > 0) {
        const fps = 1000 / delta;
        // Sample frame rate periodically (every ~60 frames)
        if (clinicalMetrics.frameRateReadings.length < 100) {
          clinicalMetrics.frameRateReadings.push(fps);
        }
      }
    }
    clinicalMetrics.lastFrameTime = now;
  }

  // ---- DOM ----
  const canvas = document.getElementById('gameCanvas');
  const ctx = canvas.getContext('2d');
  const canvasContainer = document.getElementById('canvasContainer');
  const scoreDisplay = document.getElementById('scoreDisplay');
  const errorsDisplay = document.getElementById('errorsDisplay');
  const grassDisplay = document.getElementById('grassDisplay');
  const bagDisplay = document.getElementById('bagDisplay');
  const bagStat = document.getElementById('bagStat');
  const timerDisplay = document.getElementById('timerDisplay');
  const gameTitle = document.getElementById('gameTitle');
  const toolBtn = document.getElementById('toolBtn');
  const waterBtn = document.getElementById('waterBtn');
  const toolIndicator = document.getElementById('toolIndicator');
  const stuckOverlay = document.getElementById('stuckOverlay');
  const toast = document.getElementById('toast');
  const levelSelectScreen = document.getElementById('levelSelectScreen');
  const resultScreen = document.getElementById('resultScreen');
  const resultTitle = document.getElementById('resultTitle');
  const scoreBreakdown = document.getElementById('scoreBreakdown');
  const celebCanvas = document.getElementById('celebrationCanvas');
  const celebCtx = celebCanvas.getContext('2d');
  const restartBtn = document.getElementById('restartBtn');
  const nextLevelBtn = document.getElementById('nextLevelBtn');
  const blockedOverlay = document.getElementById('blockedOverlay');
  const blockedRestartBtn = document.getElementById('blockedRestartBtn');
  const instructionOverlay = document.getElementById('instructionOverlay');
  const instructionTitle = document.getElementById('instructionTitle');
  const instructionTips = document.getElementById('instructionTips');
  const instructionStartBtn = document.getElementById('instructionStartBtn');
  const metricsOverlay = document.getElementById('metricsOverlay');
  const metricsCharts = document.getElementById('metricsCharts');
  const metricsCloseBtn = document.getElementById('metricsCloseBtn');
  const metricsBtn = document.getElementById('metricsBtn');

  // ---- API ----
  function getToken() {
    return new URLSearchParams(window.location.search).get('token');
  }

  function isDemoMode() {
    const params = new URLSearchParams(window.location.search);
    return params.get('demo') === 'true' || !getToken();
  }

  // Show demo badge if in demo mode
  if (isDemoMode()) {
    document.getElementById('demoBadge').style.display = 'inline';
    document.getElementById('backBtn').href = '/hdd/admin';
  }

  async function apiCall(body) {
    const token = getToken();
    if (!token) return null;
    try {
      const res = await fetch('/api/hdd/games', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': 'Bearer ' + token
        },
        body: JSON.stringify(body)
      });
      if (res.ok) return await res.json();
    } catch(e) { /* silent */ }
    return null;
  }

  async function startSession(level) {
    const data = await apiCall({
      action: 'start_session',
      gameSlug: 'lawn-mower',
      level: level
    });
    if (data && data.gameSessionId) {
      gameSessionId = data.gameSessionId;
    }
  }

  async function saveResult(completed) {
    const durationSeconds = Math.floor((Date.now() - startTime) / 1000);
    const maxScore = totalGrass * 10 + 500 + 300;

    // Calculate clinical biomarkers
    const clinicalStats = calculateClinicalStats();

    await apiCall({
      action: 'save_result',
      gameSessionId: gameSessionId,
      score: score,
      maxScore: maxScore,
      durationSeconds: durationSeconds,
      completed: completed,
      metrics: {
        // Legacy metrics for backward compatibility
        errors: errors,
        flowersHit: flowersHit,
        poolHits: poolHits,
        cableStucks: cableStucks,
        grassCut: grassCut,
        totalGrass: totalGrass,
        bagEmptyCount: bagEmptyCount,

        // Clinical biomarkers (DTx / Digital Phenotyping)
        ...clinicalStats,

        // Continuous time series for statistical analysis
        time_series: metricsTimeSeries
      }
    });
  }

  // ---- TOAST ----
  let toastTimeout = null;
  function showToast(msg, type, duration) {
    toast.textContent = msg;
    toast.className = 'toast ' + (type || '') + ' show';
    clearTimeout(toastTimeout);
    toastTimeout = setTimeout(() => { toast.className = 'toast'; }, duration || 2000);
  }

  // ---- LEVEL MAPS ----

  // Function to scale a level map (makes squares smaller by duplicating)
  function scaleMap(originalMap, scaleFactor) {
    const newMap = [];
    for (let r = 0; r < originalMap.length; r++) {
      for (let sf = 0; sf < scaleFactor; sf++) {
        const newRow = [];
        for (let c = 0; c < originalMap[r].length; c++) {
          for (let sc = 0; sc < scaleFactor; sc++) {
            newRow.push(originalMap[r][c]);
          }
        }
        newMap.push(newRow);
      }
    }
    return newMap;
  }

  // Scale start position accordingly
  function scalePos(pos, scaleFactor) {
    return [pos[0] * scaleFactor, pos[1] * scaleFactor];
  }

  function buildLevel(level) {
    collectedCables = new Set();
    flowerColors = {};
    usingPoolCleaner = false;
    hasPoolCleaner = false;
    poolCleaningRequired = false;
    usingWateringCan = false;
    hasWateringCan = false;
    wateringRequired = false;
    flowersWatered = 0;
    totalDryFlowers = 0;
    currentScale = 1;
    isPart2 = false;

    const F = T.FENCE, G = T.GRASS, P = T.PATH, H = T.HOUSE,
          FL = T.FLOWER, PO = T.POOL, CA = T.CABLE, CO = T.COMPOST,
          E = T.EMPTY, PD = T.POOL_DIRTY, FD = T.FLOWER_DRY, FW = T.FLOWER_WATERED;

    let map, startPos;

    // Handle scaled levels (21-60): same levels but with smaller squares
    let baseLevel = level;
    let scaleFactor = 1;

    if (level >= 21 && level <= 40) {
      // Scale 2: levels 21-40 map to levels 1-20
      baseLevel = level - 20;
      scaleFactor = 2;
      currentScale = 2;
    } else if (level >= 41 && level <= 60) {
      // Scale 3: levels 41-60 map to levels 1-20
      baseLevel = level - 40;
      scaleFactor = 3; // 3x3 for scale 3 - truly mini squares
      currentScale = 3;
    } else if (level >= 101) {
      // Part 2 levels
      isPart2 = true;
      return buildPart2Level(level);
    }

    if (baseLevel === 1) {
      // Level 1: Tutorial - Tiny garden
      map = [
        [F,F,F,F,F,F,F,F],
        [F,H,H,P,G,G,G,F],
        [F,H,H,P,G,G,G,F],
        [F,P,P,P,G,G,G,F],
        [F,G,G,G,G,G,G,F],
        [F,G,G,G,G,FL,G,F],
        [F,G,G,G,G,G,G,F],
        [F,F,F,F,F,F,F,F],
      ];
      startPos = [3, 3];
    }
    else if (baseLevel === 2) {
      // Level 2: Simple rectangular yard
      map = [
        [F,F,F,F,F,F,F,F,F,F],
        [F,H,H,H,P,G,G,G,G,F],
        [F,H,H,H,P,G,G,FL,G,F],
        [F,P,P,P,P,G,G,G,G,F],
        [F,G,G,G,G,G,G,G,G,F],
        [F,G,FL,G,G,G,G,G,G,F],
        [F,G,G,G,G,G,FL,G,G,F],
        [F,G,G,G,G,G,G,G,G,F],
        [F,F,F,F,F,F,F,F,F,F],
      ];
      startPos = [3, 4];
    }
    else if (baseLevel === 3) {
      // Level 3: More flowers to avoid
      map = [
        [F,F,F,F,F,F,F,F,F,F],
        [F,H,H,H,P,G,G,G,G,F],
        [F,H,H,H,P,G,FL,G,G,F],
        [F,P,P,P,P,G,G,G,FL,F],
        [F,G,G,G,G,G,FL,G,G,F],
        [F,G,FL,G,G,G,G,G,G,F],
        [F,G,G,G,FL,G,G,FL,G,F],
        [F,G,G,G,G,G,G,G,G,F],
        [F,F,F,F,F,F,F,F,F,F],
      ];
      startPos = [3, 4];
    }
    else if (baseLevel === 4) {
      // Level 4: Introduction to pool
      map = [
        [F,F,F,F,F,F,F,F,F,F,F,F],
        [F,H,H,H,P,G,G,G,G,G,G,F],
        [F,H,H,H,P,G,FL,G,G,FL,G,F],
        [F,P,P,P,P,G,G,G,G,G,G,F],
        [F,G,G,G,G,G,G,G,PO,PO,G,F],
        [F,G,FL,G,G,G,G,G,PO,PO,G,F],
        [F,G,G,G,G,FL,G,G,G,G,G,F],
        [F,G,G,G,G,G,G,FL,G,G,G,F],
        [F,G,G,FL,G,G,G,G,G,FL,G,F],
        [F,G,G,G,G,G,G,G,G,G,G,F],
        [F,F,F,F,F,F,F,F,F,F,F,F],
      ];
      startPos = [3, 4];
    }
    else if (baseLevel === 5) {
      // Level 5: Larger pool area
      map = [
        [F,F,F,F,F,F,F,F,F,F,F,F],
        [F,H,H,H,P,G,G,G,G,G,G,F],
        [F,H,H,H,P,G,FL,G,G,G,G,F],
        [F,P,P,P,P,G,G,G,PO,PO,PO,F],
        [F,G,G,G,G,G,G,G,PO,PO,PO,F],
        [F,G,FL,G,G,FL,G,G,G,G,G,F],
        [F,G,G,G,G,G,G,G,G,FL,G,F],
        [F,G,G,FL,G,G,FL,G,G,G,G,F],
        [F,G,G,G,G,G,G,G,G,G,G,F],
        [F,F,F,F,F,F,F,F,F,F,F,F],
      ];
      startPos = [3, 4];
    }
    else if (baseLevel === 6) {
      // Level 6: Introduction to cables
      map = [
        [F,F,F,F,F,F,F,F,F,F,F,F],
        [F,H,H,H,P,G,G,G,G,G,G,F],
        [F,H,H,H,P,G,FL,G,CA,G,G,F],
        [F,P,P,P,P,G,G,G,G,G,G,F],
        [F,G,G,G,G,G,G,FL,G,G,G,F],
        [F,G,FL,G,G,CA,G,G,G,G,G,F],
        [F,G,G,G,G,G,G,G,G,FL,G,F],
        [F,G,G,G,G,G,FL,G,G,G,G,F],
        [F,G,G,CA,G,G,G,G,G,G,G,F],
        [F,G,G,G,G,G,G,G,G,G,G,F],
        [F,F,F,F,F,F,F,F,F,F,F,F],
      ];
      startPos = [3, 4];
    }
    else if (baseLevel === 7) {
      // Level 7: L-shaped yard with cables
      map = [
        [F,F,F,F,F,F,F,F,F,F,F,F,F],
        [F,H,H,H,P,G,G,G,G,G,F,E,E],
        [F,H,H,H,P,G,FL,G,CA,G,F,E,E],
        [F,P,P,P,P,G,G,G,G,G,F,E,E],
        [F,G,G,G,G,G,G,FL,G,G,F,E,E],
        [F,G,FL,G,G,CA,G,G,G,G,F,F,F],
        [F,G,G,G,G,G,G,G,PO,PO,FL,G,F],
        [F,G,G,G,G,G,FL,G,PO,PO,G,G,F],
        [F,G,G,CA,G,G,G,G,G,G,G,G,F],
        [F,G,G,G,G,G,G,G,G,FL,G,G,F],
        [F,F,F,F,F,F,F,F,F,F,F,F,F],
      ];
      startPos = [3, 4];
    }
    else if (baseLevel === 8) {
      // Level 8: Introduction to compost/bag mechanic
      hasBag = true;
      map = [
        [F,F,F,F,F,F,F,F,F,F,F,F,F,F],
        [F,H,H,H,P,G,G,G,F,G,G,G,G,F],
        [F,H,H,H,P,G,FL,G,P,G,FL,G,G,F],
        [F,P,P,P,P,G,G,G,P,G,G,G,G,F],
        [F,G,G,G,G,G,G,G,P,G,G,FL,G,F],
        [F,G,FL,G,G,G,CA,G,P,P,P,P,CO,F],
        [F,G,G,G,G,G,G,G,F,G,G,G,G,F],
        [F,G,G,FL,G,G,FL,G,P,G,G,G,G,F],
        [F,G,G,G,G,G,G,G,P,G,FL,G,G,F],
        [F,G,CA,G,G,G,G,G,F,G,G,G,G,F],
        [F,G,G,G,G,G,G,G,F,G,G,FL,G,F],
        [F,F,F,F,F,F,F,F,F,F,F,F,F,F],
      ];
      startPos = [3, 4];
    }
    else if (baseLevel === 9) {
      // Level 9: Winding path with obstacles
      hasBag = true;
      map = [
        [F,F,F,F,F,F,F,F,F,F,F,F,F],
        [F,H,H,H,P,G,G,G,G,G,G,G,F],
        [F,H,H,H,P,G,FL,G,G,FL,G,G,F],
        [F,P,P,P,P,G,G,G,G,G,G,G,F],
        [F,G,G,G,G,G,G,FL,G,G,G,G,F],
        [F,G,FL,G,G,G,G,G,G,G,FL,G,F],
        [F,G,G,G,G,CA,G,G,PO,PO,G,G,F],
        [F,G,G,G,G,G,G,G,PO,PO,G,G,F],
        [F,G,G,FL,G,G,FL,G,G,G,G,CO,F],
        [F,G,CA,G,G,G,G,G,G,FL,G,G,F],
        [F,G,G,G,G,G,G,G,G,G,G,G,F],
        [F,F,F,F,F,F,F,F,F,F,F,F,F],
      ];
      startPos = [3, 4];
    }
    else if (baseLevel === 10) {
      // Level 10: Pool cleaning introduction
      hasBag = true;
      poolCleaningRequired = true;
      map = [
        [F,F,F,F,F,F,F,F,F,F,F,F,F,F,F],
        [F,H,H,H,P,G,G,G,F,G,G,G,G,G,F],
        [F,H,H,H,P,G,FL,G,P,G,FL,G,G,G,F],
        [F,P,P,P,P,G,G,G,P,G,G,G,PD,PD,F],
        [F,G,G,G,G,G,CA,G,P,G,G,G,PD,PD,F],
        [F,G,FL,G,G,G,G,G,P,P,P,P,P,CO,F],
        [F,G,G,G,CA,G,G,G,F,G,G,G,G,G,F],
        [F,G,G,FL,G,G,FL,G,P,G,G,FL,G,G,F],
        [F,G,G,G,G,G,G,G,P,G,G,G,G,G,F],
        [F,G,CA,G,G,FL,G,G,F,G,CA,G,FL,G,F],
        [F,G,G,G,G,G,G,G,F,G,G,G,G,G,F],
        [F,G,G,FL,G,G,G,G,F,G,G,FL,G,G,F],
        [F,F,F,F,F,F,F,F,F,F,F,F,F,F,F],
      ];
      startPos = [3, 4];
    }
    else if (baseLevel === 11) {
      // Level 11: Double garden
      hasBag = true;
      map = [
        [F,F,F,F,F,F,F,F,F,F,F,F,F,F,F],
        [F,H,H,H,P,G,G,G,G,G,G,G,G,G,F],
        [F,H,H,H,P,G,FL,G,G,FL,G,G,FL,G,F],
        [F,P,P,P,P,G,G,G,G,G,G,G,G,G,F],
        [F,G,G,G,G,G,G,FL,G,G,G,FL,G,G,F],
        [F,G,FL,G,G,G,G,G,G,G,G,G,G,G,F],
        [F,F,F,F,P,F,F,F,F,P,F,F,F,F,F],
        [F,G,G,G,P,G,G,G,G,P,G,G,G,G,F],
        [F,G,FL,G,P,G,FL,G,G,P,G,FL,G,G,F],
        [F,G,G,G,P,P,P,P,P,P,G,G,G,CO,F],
        [F,G,G,FL,G,G,G,G,G,G,G,G,FL,G,F],
        [F,G,G,G,G,G,FL,G,G,FL,G,G,G,G,F],
        [F,F,F,F,F,F,F,F,F,F,F,F,F,F,F],
      ];
      startPos = [3, 4];
    }
    else if (baseLevel === 12) {
      // Level 12: Narrow passages
      hasBag = true;
      map = [
        [F,F,F,F,F,F,F,F,F,F,F,F,F,F],
        [F,H,H,H,P,G,G,F,G,G,G,G,G,F],
        [F,H,H,H,P,G,FL,F,G,FL,G,G,G,F],
        [F,P,P,P,P,G,G,P,G,G,G,G,G,F],
        [F,G,G,G,G,G,G,P,G,G,FL,G,G,F],
        [F,G,FL,G,G,CA,G,P,G,G,G,G,G,F],
        [F,G,G,G,G,G,G,P,P,P,P,P,G,F],
        [F,G,G,FL,G,G,G,F,G,G,G,P,G,F],
        [F,G,G,G,G,G,G,F,G,FL,G,P,CO,F],
        [F,G,CA,G,G,FL,G,F,G,G,G,P,G,F],
        [F,G,G,G,G,G,G,G,G,G,G,G,G,F],
        [F,F,F,F,F,F,F,F,F,F,F,F,F,F],
      ];
      startPos = [3, 4];
    }
    else if (baseLevel === 13) {
      // Level 13: Maze-like with many cables
      hasBag = true;
      map = [
        [F,F,F,F,F,F,F,F,F,F,F,F,F,F],
        [F,H,H,H,P,G,G,G,G,G,G,G,G,F],
        [F,H,H,H,P,G,FL,G,CA,FL,G,G,G,F],
        [F,P,P,P,P,G,G,G,G,G,G,G,G,F],
        [F,G,G,G,G,F,F,P,F,F,G,G,G,F],
        [F,G,FL,G,G,F,G,P,G,F,G,FL,G,F],
        [F,G,G,G,G,P,P,P,P,P,G,G,G,F],
        [F,G,G,FL,G,P,G,CA,G,P,G,G,CO,F],
        [F,G,CA,G,G,P,FL,G,G,P,G,FL,G,F],
        [F,G,G,G,G,P,G,G,G,P,G,G,G,F],
        [F,G,G,FL,G,G,CA,G,G,G,G,G,G,F],
        [F,F,F,F,F,F,F,F,F,F,F,F,F,F],
      ];
      startPos = [3, 4];
    }
    else if (baseLevel === 14) {
      // Level 14: Big pool zone
      hasBag = true;
      poolCleaningRequired = true;
      map = [
        [F,F,F,F,F,F,F,F,F,F,F,F,F,F,F],
        [F,H,H,H,P,G,G,G,G,G,G,G,G,G,F],
        [F,H,H,H,P,G,FL,G,G,FL,G,G,G,G,F],
        [F,P,P,P,P,G,G,G,G,G,G,G,G,G,F],
        [F,G,G,G,G,G,G,FL,G,G,PD,PD,PD,G,F],
        [F,G,FL,G,G,CA,G,G,G,G,PD,PD,PD,G,F],
        [F,G,G,G,G,G,G,G,G,G,PD,PD,PD,G,F],
        [F,G,G,FL,G,G,FL,G,G,G,G,G,G,CO,F],
        [F,G,CA,G,G,G,G,G,G,FL,G,G,G,G,F],
        [F,G,G,G,G,FL,G,G,G,G,G,FL,G,G,F],
        [F,G,G,G,G,G,G,CA,G,G,G,G,G,G,F],
        [F,F,F,F,F,F,F,F,F,F,F,F,F,F,F],
      ];
      startPos = [3, 4];
    }
    else if (baseLevel === 15) {
      // Level 15: U-shaped garden
      hasBag = true;
      map = [
        [F,F,F,F,F,F,F,F,F,F,F,F,F,F,F],
        [F,H,H,H,P,G,G,G,F,G,G,G,G,G,F],
        [F,H,H,H,P,G,FL,G,F,G,FL,G,G,G,F],
        [F,P,P,P,P,G,G,G,F,G,G,G,G,G,F],
        [F,G,G,G,G,G,G,FL,F,G,G,FL,G,G,F],
        [F,G,FL,G,G,CA,G,G,F,G,G,G,G,G,F],
        [F,G,G,G,G,G,G,G,F,G,G,G,FL,G,F],
        [F,G,G,FL,G,G,FL,G,F,G,FL,G,G,G,F],
        [F,G,CA,G,G,G,G,G,P,P,P,P,P,CO,F],
        [F,G,G,G,G,FL,G,G,G,G,G,G,G,G,F],
        [F,G,G,G,G,G,G,CA,G,G,FL,G,G,G,F],
        [F,F,F,F,F,F,F,F,F,F,F,F,F,F,F],
      ];
      startPos = [3, 4];
    }
    else if (baseLevel === 16) {
      // Level 16: Complex multi-zone
      hasBag = true;
      poolCleaningRequired = true;
      map = [
        [F,F,F,F,F,F,F,F,F,F,F,F,F,F,F,F],
        [F,H,H,H,P,G,G,G,G,F,G,G,G,G,G,F],
        [F,H,H,H,P,G,FL,G,G,P,G,FL,G,G,G,F],
        [F,P,P,P,P,G,G,G,G,P,G,G,G,G,G,F],
        [F,G,G,G,G,G,G,FL,G,P,G,G,FL,G,G,F],
        [F,G,FL,G,G,CA,G,G,G,P,G,G,G,PD,PD,F],
        [F,G,G,G,G,G,G,G,F,P,F,G,G,PD,PD,F],
        [F,G,G,FL,G,G,FL,G,P,P,P,G,G,G,G,F],
        [F,G,CA,G,G,G,G,G,P,G,G,G,FL,G,CO,F],
        [F,G,G,G,G,FL,G,G,P,G,CA,G,G,G,G,F],
        [F,G,G,G,G,G,G,CA,P,G,G,G,FL,G,G,F],
        [F,F,F,F,F,F,F,F,F,F,F,F,F,F,F,F],
      ];
      startPos = [3, 4];
    }
    else if (baseLevel === 17) {
      // Level 17: Many isolated zones
      hasBag = true;
      map = [
        [F,F,F,F,F,F,F,F,F,F,F,F,F,F,F,F],
        [F,H,H,H,P,G,G,F,G,G,F,G,G,G,G,F],
        [F,H,H,H,P,G,FL,P,G,FL,P,G,FL,G,G,F],
        [F,P,P,P,P,G,G,P,G,G,P,G,G,G,G,F],
        [F,G,G,G,G,G,G,P,P,P,P,G,G,FL,G,F],
        [F,G,FL,G,G,CA,G,F,G,G,F,G,G,G,G,F],
        [F,F,F,P,F,F,F,F,G,G,F,F,F,P,F,F],
        [F,G,G,P,G,G,G,G,G,G,G,G,G,P,G,F],
        [F,G,FL,P,G,FL,G,G,G,FL,G,G,FL,P,CO,F],
        [F,G,G,P,G,G,G,CA,G,G,G,G,G,P,G,F],
        [F,G,G,P,P,P,P,P,P,P,P,P,P,P,G,F],
        [F,G,G,G,G,FL,G,G,G,G,FL,G,G,G,G,F],
        [F,F,F,F,F,F,F,F,F,F,F,F,F,F,F,F],
      ];
      startPos = [3, 4];
    }
    else if (baseLevel === 18) {
      // Level 18: Expert obstacles
      hasBag = true;
      poolCleaningRequired = true;
      map = [
        [F,F,F,F,F,F,F,F,F,F,F,F,F,F,F,F],
        [F,H,H,H,P,G,G,G,G,G,G,G,G,G,G,F],
        [F,H,H,H,P,G,FL,G,CA,FL,G,CA,FL,G,G,F],
        [F,P,P,P,P,G,G,G,G,G,G,G,G,G,G,F],
        [F,G,G,G,G,G,G,FL,G,G,G,FL,G,PD,PD,F],
        [F,G,FL,G,G,CA,G,G,G,CA,G,G,G,PD,PD,F],
        [F,G,G,G,G,G,G,G,G,G,G,G,G,G,G,F],
        [F,G,G,FL,G,G,FL,G,G,G,G,FL,G,G,G,F],
        [F,G,CA,G,G,G,G,G,PO,PO,G,G,G,G,CO,F],
        [F,G,G,G,G,FL,G,G,PO,PO,G,CA,G,G,G,F],
        [F,G,G,G,G,G,G,CA,G,G,G,G,FL,G,G,F],
        [F,F,F,F,F,F,F,F,F,F,F,F,F,F,F,F],
      ];
      startPos = [3, 4];
    }
    else if (baseLevel === 19) {
      // Level 19: Mastery test
      hasBag = true;
      poolCleaningRequired = true;
      map = [
        [F,F,F,F,F,F,F,F,F,F,F,F,F,F,F,F,F],
        [F,H,H,H,P,G,G,G,G,F,G,G,G,G,G,G,F],
        [F,H,H,H,P,G,FL,G,CA,P,G,FL,G,CA,FL,G,F],
        [F,P,P,P,P,G,G,G,G,P,G,G,G,G,G,G,F],
        [F,G,G,G,G,G,G,FL,G,P,G,G,FL,G,G,G,F],
        [F,G,FL,G,G,CA,G,G,G,P,G,G,G,PD,PD,PD,F],
        [F,G,G,G,G,G,G,G,F,P,F,G,G,PD,PD,PD,F],
        [F,G,G,FL,G,G,FL,G,P,P,P,G,G,G,G,G,F],
        [F,G,CA,G,G,G,G,G,P,G,G,G,FL,G,G,G,F],
        [F,G,G,G,G,FL,G,G,P,G,CA,G,G,G,FL,CO,F],
        [F,G,G,G,G,G,G,CA,P,G,G,G,FL,G,G,G,F],
        [F,G,FL,G,G,G,G,G,P,G,G,G,G,G,G,G,F],
        [F,F,F,F,F,F,F,F,F,F,F,F,F,F,F,F,F],
      ];
      startPos = [3, 4];
    }
    else if (baseLevel === 20) {
      // Level 20: Grand Master Challenge
      hasBag = true;
      poolCleaningRequired = true;
      map = [
        [F,F,F,F,F,F,F,F,F,F,F,F,F,F,F,F,F,F],
        [F,H,H,H,P,G,G,G,G,G,F,G,G,G,G,G,G,F],
        [F,H,H,H,P,G,FL,G,CA,G,P,G,FL,G,CA,G,G,F],
        [F,P,P,P,P,G,G,G,G,G,P,G,G,G,G,G,G,F],
        [F,G,G,G,G,G,G,FL,G,G,P,G,G,FL,G,G,G,F],
        [F,G,FL,G,G,CA,G,G,G,G,P,G,G,G,PD,PD,G,F],
        [F,G,G,G,G,G,G,G,F,F,P,F,F,G,PD,PD,G,F],
        [F,G,G,FL,G,G,FL,G,G,G,P,G,G,G,G,G,G,F],
        [F,F,F,P,F,F,F,F,G,G,P,G,G,F,F,F,F,F],
        [F,G,G,P,G,G,G,G,G,G,P,P,P,P,P,P,CO,F],
        [F,G,FL,P,G,FL,G,CA,G,G,G,G,G,CA,G,G,G,F],
        [F,G,G,P,G,G,G,G,PO,PO,G,G,G,G,FL,G,G,F],
        [F,G,G,P,P,P,P,G,PO,PO,G,FL,G,G,G,G,G,F],
        [F,G,FL,G,G,G,P,G,G,G,G,G,G,G,G,FL,G,F],
        [F,G,G,G,CA,G,P,G,FL,G,CA,G,G,G,G,G,G,F],
        [F,F,F,F,F,F,F,F,F,F,F,F,F,F,F,F,F,F],
      ];
      startPos = [3, 4];
    }
    else {
      // Fallback for levels beyond 20 - use level 20 template
      hasBag = true;
      poolCleaningRequired = true;
      map = [
        [F,F,F,F,F,F,F,F,F,F,F,F,F,F,F,F,F,F],
        [F,H,H,H,P,G,G,G,G,G,F,G,G,G,G,G,G,F],
        [F,H,H,H,P,G,FL,G,CA,G,P,G,FL,G,CA,G,G,F],
        [F,P,P,P,P,G,G,G,G,G,P,G,G,G,G,G,G,F],
        [F,G,G,G,G,G,G,FL,G,G,P,G,G,FL,G,G,G,F],
        [F,G,FL,G,G,CA,G,G,G,G,P,G,G,G,PD,PD,G,F],
        [F,G,G,G,G,G,G,G,F,F,P,F,F,G,PD,PD,G,F],
        [F,G,G,FL,G,G,FL,G,G,G,P,G,G,G,G,G,G,F],
        [F,F,F,P,F,F,F,F,G,G,P,G,G,F,F,F,F,F],
        [F,G,G,P,G,G,G,G,G,G,P,P,P,P,P,P,CO,F],
        [F,G,FL,P,G,FL,G,CA,G,G,G,G,G,CA,G,G,G,F],
        [F,G,G,P,G,G,G,G,PO,PO,G,G,G,G,FL,G,G,F],
        [F,G,G,P,P,P,P,G,PO,PO,G,FL,G,G,G,G,G,F],
        [F,G,FL,G,G,G,P,G,G,G,G,G,G,G,G,FL,G,F],
        [F,G,G,G,CA,G,P,G,FL,G,CA,G,G,G,G,G,G,F],
        [F,F,F,F,F,F,F,F,F,F,F,F,F,F,F,F,F,F],
      ];
      startPos = [3, 4];
    }

    // Assign random flower colors
    for (let r = 0; r < map.length; r++) {
      for (let c = 0; c < map[r].length; c++) {
        if (map[r][c] === T.FLOWER || map[r][c] === T.FLOWER_DRY) {
          flowerColors[r + ',' + c] = FLOWER_PALETTE[Math.floor(Math.random() * FLOWER_PALETTE.length)];
        }
      }
    }

    // Apply scaling if needed
    if (scaleFactor > 1) {
      map = scaleMap(map, scaleFactor);
      startPos = scalePos(startPos, scaleFactor);
      // Re-assign flower colors for scaled map
      flowerColors = {};
      for (let r = 0; r < map.length; r++) {
        for (let c = 0; c < map[r].length; c++) {
          if (map[r][c] === T.FLOWER || map[r][c] === T.FLOWER_DRY) {
            flowerColors[r + ',' + c] = FLOWER_PALETTE[Math.floor(Math.random() * FLOWER_PALETTE.length)];
          }
        }
      }
    }

    return { map, startPos };
  }

  // ---- PART 2 LEVELS: Full Garden Maintenance ----
  function buildPart2Level(level) {
    const F = T.FENCE, G = T.GRASS, P = T.PATH, H = T.HOUSE,
          FL = T.FLOWER, PO = T.POOL, CA = T.CABLE, CO = T.COMPOST,
          E = T.EMPTY, PD = T.POOL_DIRTY, FD = T.FLOWER_DRY;

    let map, startPos;
    hasBag = true;
    poolCleaningRequired = true;
    wateringRequired = true;
    hasWateringCan = true;
    hasPoolCleaner = true;

    if (level === 101) {
      // Part 2 Level 1: Tutorial - learn all 3 tools
      map = [
        [F,F,F,F,F,F,F,F,F,F,F,F],
        [F,H,H,H,P,G,G,G,G,G,G,F],
        [F,H,H,H,P,G,G,FD,G,G,G,F],
        [F,P,P,P,P,G,G,G,G,G,G,F],
        [F,G,G,G,G,G,G,G,G,G,G,F],
        [F,G,FD,G,G,G,G,G,PD,PD,G,F],
        [F,G,G,G,G,G,G,G,PD,PD,G,F],
        [F,G,G,G,G,G,FD,G,G,G,CO,F],
        [F,G,G,G,G,G,G,G,G,G,G,F],
        [F,F,F,F,F,F,F,F,F,F,F,F],
      ];
      startPos = [3, 4];
    }
    else if (level === 102) {
      // Part 2 Level 2: Garden Rescue
      map = [
        [F,F,F,F,F,F,F,F,F,F,F,F,F,F],
        [F,H,H,H,P,G,G,G,G,G,G,G,G,F],
        [F,H,H,H,P,G,FD,G,G,FD,G,G,G,F],
        [F,P,P,P,P,G,G,G,G,G,G,G,G,F],
        [F,G,G,G,G,G,G,G,PD,PD,PD,G,G,F],
        [F,G,FD,G,G,CA,G,G,PD,PD,PD,G,G,F],
        [F,G,G,G,G,G,G,G,G,G,G,G,G,F],
        [F,G,G,G,G,G,FD,G,G,G,G,G,CO,F],
        [F,G,G,FD,G,G,G,G,G,FD,G,G,G,F],
        [F,G,G,G,G,G,G,G,G,G,G,G,G,F],
        [F,F,F,F,F,F,F,F,F,F,F,F,F,F],
      ];
      startPos = [3, 4];
    }
    else if (level === 103) {
      // Part 2 Level 3: Abandoned Mansion
      map = [
        [F,F,F,F,F,F,F,F,F,F,F,F,F,F,F,F],
        [F,H,H,H,P,G,G,G,G,F,G,G,G,G,G,F],
        [F,H,H,H,P,G,FD,G,G,P,G,FD,G,G,G,F],
        [F,P,P,P,P,G,G,G,G,P,G,G,G,G,G,F],
        [F,G,G,G,G,G,G,G,G,P,G,G,FD,G,G,F],
        [F,G,FD,G,G,CA,G,G,G,P,G,G,G,PD,PD,F],
        [F,G,G,G,G,G,G,G,F,P,F,G,G,PD,PD,F],
        [F,G,G,FD,G,G,FD,G,P,P,P,G,G,G,G,F],
        [F,G,CA,G,G,G,G,G,P,G,G,G,FD,G,CO,F],
        [F,G,G,G,G,FD,G,G,P,G,CA,G,G,G,G,F],
        [F,G,G,FD,G,G,G,CA,P,G,G,G,FD,G,G,F],
        [F,F,F,F,F,F,F,F,F,F,F,F,F,F,F,F],
      ];
      startPos = [3, 4];
    }
    else if (level === 104) {
      // Part 2 Level 4: Luxury Hotel
      map = [
        [F,F,F,F,F,F,F,F,F,F,F,F,F,F,F,F,F],
        [F,H,H,H,P,G,G,G,G,G,F,G,G,G,G,G,F],
        [F,H,H,H,P,G,FD,G,G,G,P,G,FD,G,G,G,F],
        [F,P,P,P,P,G,G,G,G,G,P,G,G,G,G,G,F],
        [F,G,G,G,G,G,G,FD,G,G,P,G,G,FD,G,G,F],
        [F,G,FD,G,G,CA,G,G,G,G,P,G,G,G,PD,PD,F],
        [F,G,G,G,G,G,G,G,F,F,P,F,F,G,PD,PD,F],
        [F,G,G,FD,G,G,FD,G,G,G,P,G,G,G,PD,PD,F],
        [F,F,F,P,F,F,F,F,G,G,P,G,G,F,F,F,F],
        [F,G,G,P,G,G,G,G,G,G,P,P,P,P,P,CO,F],
        [F,G,FD,P,G,FD,G,CA,G,G,G,G,G,CA,G,G,F],
        [F,G,G,P,G,G,G,G,PD,PD,G,G,G,G,FD,G,F],
        [F,G,G,P,P,P,P,G,PD,PD,G,FD,G,G,G,G,F],
        [F,G,FD,G,G,G,P,G,G,G,G,G,G,G,G,FD,F],
        [F,F,F,F,F,F,F,F,F,F,F,F,F,F,F,F,F],
      ];
      startPos = [3, 4];
    }
    else {
      // Part 2 Level 5: Municipal Park (default)
      map = [
        [F,F,F,F,F,F,F,F,F,F,F,F,F,F,F,F,F,F],
        [F,H,H,H,P,G,G,G,G,G,F,G,G,G,G,G,G,F],
        [F,H,H,H,P,G,FD,G,CA,G,P,G,FD,G,CA,G,G,F],
        [F,P,P,P,P,G,G,G,G,G,P,G,G,G,G,G,G,F],
        [F,G,G,G,G,G,G,FD,G,G,P,G,G,FD,G,G,G,F],
        [F,G,FD,G,G,CA,G,G,G,G,P,G,G,G,PD,PD,G,F],
        [F,G,G,G,G,G,G,G,F,F,P,F,F,G,PD,PD,G,F],
        [F,G,G,FD,G,G,FD,G,G,G,P,G,G,G,PD,PD,G,F],
        [F,F,F,P,F,F,F,F,G,G,P,G,G,F,F,F,F,F],
        [F,G,G,P,G,G,G,G,G,G,P,P,P,P,P,P,CO,F],
        [F,G,FD,P,G,FD,G,CA,G,G,G,G,G,CA,G,G,G,F],
        [F,G,G,P,G,G,G,G,PO,PO,G,G,G,G,FD,G,G,F],
        [F,G,G,P,P,P,P,G,PO,PO,G,FD,G,G,G,G,G,F],
        [F,G,FD,G,G,G,P,G,G,G,G,G,G,G,G,FD,G,F],
        [F,G,G,G,CA,G,P,G,FD,G,CA,G,G,FD,G,G,G,F],
        [F,F,F,F,F,F,F,F,F,F,F,F,F,F,F,F,F,F],
      ];
      startPos = [3, 4];
    }

    // Count dry flowers for Part 2
    totalDryFlowers = 0;
    for (let r = 0; r < map.length; r++) {
      for (let c = 0; c < map[r].length; c++) {
        if (map[r][c] === T.FLOWER_DRY) {
          totalDryFlowers++;
        }
      }
    }

    // Assign flower colors
    for (let r = 0; r < map.length; r++) {
      for (let c = 0; c < map[r].length; c++) {
        if (map[r][c] === T.FLOWER || map[r][c] === T.FLOWER_DRY) {
          flowerColors[r + ',' + c] = FLOWER_PALETTE[Math.floor(Math.random() * FLOWER_PALETTE.length)];
        }
      }
    }

    return { map, startPos };
  }

  // ---- INSTRUCTION SYSTEM ----
  function getLevelInstructions(level) {
    const baseInstructions = [
      'La cortadora solo puede avanzar cortando cesped o por donde ya esta cortado.',
      'Planifica bien tu recorrido antes de moverte.',
      'Usa las flechas del teclado, WASD, D-Pad tactil o arrastra con click derecho.',
    ];

    let specific = [];
    let title = 'Instrucciones del Nivel';

    if (level === 1) {
      title = 'Tutorial - Aprende los controles';
      specific = ['Este es un jardin pequeno para practicar.', 'Evita pisar las flores!'];
    } else if (level >= 2 && level <= 3) {
      specific = ['Hay flores en el jardin, no las pises!'];
    } else if (level >= 4 && level <= 5) {
      specific = ['Cuidado con la piscina! Si caes, pierdes puntos.', 'No puedes caminar sobre la piscina.'];
    } else if (level >= 6 && level <= 7) {
      specific = ['Hay cables en el suelo que te atascaran 2 segundos.', 'Toca/clickea cables cercanos para recogerlos antes de pisarlos.'];
    } else if (level === 8) {
      title = 'La Compostera - Nueva mecanica!';
      specific = [
        'Tu bolsa de recoleccion tiene capacidad limitada (15).',
        'Cuando se llene, ve a la compostera (marron) para vaciarla.',
        'IMPORTANTE: Planifica tu camino de ida a la compostera desde el inicio!',
      ];
    } else if (level >= 9 && level <= 10) {
      specific = [
        'Bolsa limitada: planifica tu recorrido hacia la compostera.',
        level >= 10 ? 'Usa el boton "Limpiador de Piscina" para limpiar agua sucia.' : '',
      ].filter(Boolean);
    } else if (level >= 11 && level <= 20) {
      specific = ['Nivel avanzado: multiples mecanicas activas.', 'Usa el boton Reiniciar si te bloqueas.'];
    } else if (level >= 21 && level <= 40) {
      title = 'Escala 2 - Cuadros mas pequenos';
      specific = ['Los cuadros son mas finos, requiere mayor precision.', 'Mismas reglas, mayor dificultad motriz.'];
    } else if (level >= 41 && level <= 60) {
      title = 'Escala 3 - Cuadros mini';
      specific = ['Cuadros diminutos para expertos.', 'Maxima precision requerida.'];
    } else if (level >= 101) {
      title = 'Parte 2 - Jardinero Completo';
      specific = [
        'Tres herramientas: Cortadora, Limpiador de Piscina y Regadera.',
        'Corta el cesped, limpia la piscina sucia y riega las flores secas.',
        'Cambia entre herramientas con los botones de la esquina.',
      ];
    }

    return { title, tips: [...baseInstructions, ...specific] };
  }

  function showInstructions(level, callback) {
    const { title, tips } = getLevelInstructions(level);
    instructionTitle.textContent = title;
    instructionTips.innerHTML = tips.map(t => '<li>' + t + '</li>').join('');
    instructionOverlay.classList.remove('hidden');

    instructionStartBtn.onclick = function() {
      instructionOverlay.classList.add('hidden');
      if (callback) callback();
    };
  }

  // ---- BLOCKED DETECTION (BFS) ----
  function canReachGrass() {
    // BFS from player position to see if any uncut grass is reachable
    // Player can move to: CUT, PATH, GRASS, CABLE (collected), COMPOST, FLOWER_WATERED, POOL (if pool cleaner), FLOWER_DRY (if watering)
    const visited = new Set();
    const queue = [[playerX, playerY]];
    visited.add(playerX + ',' + playerY);
    let grassReachable = false;

    while (queue.length > 0) {
      const [cx, cy] = queue.shift();
      const dirs = [[0,1],[0,-1],[1,0],[-1,0]];
      for (const [ddx, ddy] of dirs) {
        const nx = cx + ddx;
        const ny = cy + ddy;
        const key = nx + ',' + ny;
        if (nx < 0 || nx >= gridW || ny < 0 || ny >= gridH) continue;
        if (visited.has(key)) continue;
        visited.add(key);
        const tile = grid[ny][nx];
        // Walkable tiles for pathfinding
        if (tile === T.CUT || tile === T.PATH || tile === T.COMPOST || tile === T.FLOWER_WATERED) {
          queue.push([nx, ny]);
        } else if (tile === T.GRASS) {
          // Check if we can actually cut it (bag not permanently full)
          if (hasBag && bagCount >= bagCapacity) {
            // Can we reach compost from here?
            // For simplicity, if there's any grass reachable from anywhere, mark as reachable
            // The bag full check is separate
          }
          grassReachable = true;
          queue.push([nx, ny]);
        } else if (tile === T.CABLE) {
          const cableKey = ny + ',' + nx;
          if (collectedCables.has(cableKey)) {
            queue.push([nx, ny]); // Already collected, treated as cut
          } else {
            // Cable will get collected when stepped on (after stuck), so grass behind cable is reachable
            grassReachable = true;
            queue.push([nx, ny]);
          }
        } else if (tile === T.POOL_DIRTY && usingPoolCleaner) {
          queue.push([nx, ny]);
        } else if (tile === T.FLOWER_DRY && usingWateringCan) {
          queue.push([nx, ny]);
        }
      }
    }

    return grassReachable || (grassCut >= totalGrass);
  }

  function checkBlocked() {
    if (!gameRunning || isStuck || isBlocked) return;
    if (grassCut >= totalGrass) return; // Already won or about to win

    // Check if bag is full and compostera is unreachable
    if (hasBag && bagCount >= bagCapacity) {
      // BFS to check if compost is reachable from current position
      const visited = new Set();
      const queue = [[playerX, playerY]];
      visited.add(playerX + ',' + playerY);
      let compostReachable = false;
      while (queue.length > 0) {
        const [cx, cy] = queue.shift();
        const dirs = [[0,1],[0,-1],[1,0],[-1,0]];
        for (const [ddx, ddy] of dirs) {
          const nx = cx + ddx;
          const ny = cy + ddy;
          const key = nx + ',' + ny;
          if (nx < 0 || nx >= gridW || ny < 0 || ny >= gridH) continue;
          if (visited.has(key)) continue;
          visited.add(key);
          const tile = grid[ny][nx];
          if (tile === T.COMPOST) {
            compostReachable = true;
            break;
          }
          if (tile === T.CUT || tile === T.PATH || tile === T.FLOWER_WATERED) {
            queue.push([nx, ny]);
          }
        }
        if (compostReachable) break;
      }
      if (!compostReachable) {
        showBlocked('Bolsa llena y no puedes llegar a la compostera!');
        return;
      }
    }

    // Check if any uncut grass is reachable
    if (!canReachGrass()) {
      showBlocked('Te bloqueaste! No hay cesped alcanzable.');
    }
  }

  function showBlocked(message) {
    isBlocked = true;
    const blockedText = blockedOverlay.querySelector('.blocked-text');
    blockedText.textContent = message;
    blockedOverlay.classList.remove('hidden');
  }

  // ---- NEXT LEVEL LOGIC ----
  function getNextLevel(current) {
    if (current >= 1 && current <= 19) return current + 1;
    if (current === 20) return 21; // Go to Scale 2
    if (current >= 21 && current < 25) return 25;
    if (current >= 25 && current < 30) return 30;
    if (current >= 30 && current < 40) return 40;
    if (current === 40) return 41; // Go to Scale 3
    if (current >= 41 && current < 50) return 50;
    if (current >= 50 && current < 60) return 60;
    if (current === 60) return 101; // Go to Part 2
    if (current >= 101 && current <= 104) return current + 1;
    return null; // No next level
  }

  // ---- METRICS CHART RENDERING ----
  function drawLineChart(canvasEl, data, labels, color, ylabel) {
    if (!canvasEl || !data || data.length === 0) return;
    const ctx2 = canvasEl.getContext('2d');
    const w = canvasEl.width = canvasEl.parentElement.clientWidth - 16;
    const h = canvasEl.height = 140;
    const pad = { top: 10, right: 10, bottom: 25, left: 40 };
    const chartW = w - pad.left - pad.right;
    const chartH = h - pad.top - pad.bottom;

    ctx2.clearRect(0, 0, w, h);
    ctx2.fillStyle = '#fff';
    ctx2.fillRect(0, 0, w, h);

    if (data.length < 2) {
      ctx2.fillStyle = '#94a3b8';
      ctx2.font = '12px sans-serif';
      ctx2.textAlign = 'center';
      ctx2.fillText('Datos insuficientes', w/2, h/2);
      return;
    }

    const maxVal = Math.max(...data, 1);
    const minVal = Math.min(...data, 0);
    const range = maxVal - minVal || 1;

    // Grid lines
    ctx2.strokeStyle = '#e2e8f0';
    ctx2.lineWidth = 1;
    for (let i = 0; i <= 4; i++) {
      const y = pad.top + (chartH / 4) * i;
      ctx2.beginPath();
      ctx2.moveTo(pad.left, y);
      ctx2.lineTo(w - pad.right, y);
      ctx2.stroke();
      // Y axis labels
      const val = maxVal - (range / 4) * i;
      ctx2.fillStyle = '#94a3b8';
      ctx2.font = '10px sans-serif';
      ctx2.textAlign = 'right';
      ctx2.fillText(Math.round(val), pad.left - 4, y + 4);
    }

    // Data line
    ctx2.strokeStyle = color;
    ctx2.lineWidth = 2;
    ctx2.beginPath();
    for (let i = 0; i < data.length; i++) {
      const x = pad.left + (i / (data.length - 1)) * chartW;
      const y = pad.top + chartH - ((data[i] - minVal) / range) * chartH;
      if (i === 0) ctx2.moveTo(x, y);
      else ctx2.lineTo(x, y);
    }
    ctx2.stroke();

    // Fill under
    ctx2.lineTo(pad.left + chartW, pad.top + chartH);
    ctx2.lineTo(pad.left, pad.top + chartH);
    ctx2.closePath();
    ctx2.fillStyle = color.replace(')', ',0.1)').replace('rgb', 'rgba');
    ctx2.fill();

    // X axis label
    ctx2.fillStyle = '#64748b';
    ctx2.font = '10px sans-serif';
    ctx2.textAlign = 'center';
    ctx2.fillText('Tiempo (s)', w / 2, h - 2);

    // Y axis label
    ctx2.save();
    ctx2.translate(10, h / 2);
    ctx2.rotate(-Math.PI / 2);
    ctx2.fillText(ylabel || '', 0, 0);
    ctx2.restore();
  }

  function drawBarChart(canvasEl, data, labels, color, ylabel) {
    if (!canvasEl || !data || data.length === 0) return;
    const ctx2 = canvasEl.getContext('2d');
    const w = canvasEl.width = canvasEl.parentElement.clientWidth - 16;
    const h = canvasEl.height = 140;
    const pad = { top: 10, right: 10, bottom: 25, left: 40 };
    const chartW = w - pad.left - pad.right;
    const chartH = h - pad.top - pad.bottom;

    ctx2.clearRect(0, 0, w, h);
    ctx2.fillStyle = '#fff';
    ctx2.fillRect(0, 0, w, h);

    if (data.length === 0) return;

    const maxVal = Math.max(...data, 1);
    const barW = Math.max(2, chartW / data.length - 1);

    for (let i = 0; i < data.length; i++) {
      const x = pad.left + (i / data.length) * chartW;
      const barH = (data[i] / maxVal) * chartH;
      ctx2.fillStyle = color;
      ctx2.fillRect(x, pad.top + chartH - barH, barW, barH);
    }

    // X axis label
    ctx2.fillStyle = '#64748b';
    ctx2.font = '10px sans-serif';
    ctx2.textAlign = 'center';
    ctx2.fillText(labels ? labels : 'Eventos', w / 2, h - 2);

    // Y axis label
    ctx2.save();
    ctx2.translate(10, h / 2);
    ctx2.rotate(-Math.PI / 2);
    ctx2.fillStyle = '#64748b';
    ctx2.fillText(ylabel || '', 0, 0);
    ctx2.restore();
  }

  function showMetricsPanel() {
    metricsOverlay.classList.remove('hidden');
    const stats = calculateClinicalStats();

    metricsCharts.innerHTML = '';

    // Chart 1: Cumulative grass cut over time
    addChartBlock('Cesped Cortado (acumulado)', 'grassChart');
    // Chart 2: Score over time
    addChartBlock('Puntuacion (acumulado)', 'scoreChart');
    // Chart 3: Errors over time
    addChartBlock('Errores (acumulado)', 'errorsChart');
    // Chart 4: Movement efficiency over time
    addChartBlock('Eficiencia de Movimiento', 'effChart');
    // Chart 5: Reaction times (bar chart)
    addChartBlock('Tiempos de Reaccion (ms)', 'rtChart');
    // Chart 6: Pause durations (bar chart)
    addChartBlock('Pausas detectadas (ms)', 'pauseChart');

    // Summary stats
    const summaryDiv = document.createElement('div');
    summaryDiv.style.cssText = 'grid-column: 1 / -1; background:#f0fdf4; border:1px solid #bbf7d0; border-radius:10px; padding:1rem;';
    summaryDiv.innerHTML = '<h3 style="font-size:0.9rem; color:#15803d; margin-bottom:0.5rem;">Resumen Estadistico (FDA Biomarkers)</h3>'
      + '<div style="display:grid; grid-template-columns:repeat(auto-fit,minmax(200px,1fr)); gap:0.5rem; font-size:0.82rem;">'
      + metricItem('RT Media', stats.clinical_markers.mean_reaction_time_ms + ' ms')
      + metricItem('RT Variabilidad (SD)', stats.clinical_markers.rt_variability_sd + ' ms')
      + metricItem('Coef. Variacion RT', (stats.clinical_markers.rt_coefficient_of_variation * 100).toFixed(1) + '%')
      + metricItem('Errores Omision', stats.clinical_markers.omission_errors)
      + metricItem('Errores Comision', stats.clinical_markers.commission_errors)
      + metricItem('Ratio Impulsividad', (stats.clinical_markers.impulsivity_ratio * 100).toFixed(1) + '%')
      + metricItem('Eficiencia Movimiento', (stats.clinical_markers.movement_efficiency * 100).toFixed(1) + '%')
      + metricItem('Eficiencia Trayecto', (stats.clinical_markers.path_efficiency * 100).toFixed(1) + '%')
      + metricItem('Pausas >3s', stats.clinical_markers.long_pauses_count)
      + metricItem('Pausa Media', stats.clinical_markers.avg_pause_duration_ms + ' ms')
      + metricItem('T. Primera Accion', stats.clinical_markers.time_to_first_action_ms + ' ms')
      + metricItem('Reinicios', stats.device_context.session_restarts)
      + '</div>';
    metricsCharts.appendChild(summaryDiv);

    // Render charts after DOM is ready
    requestAnimationFrame(() => {
      const ts = metricsTimeSeries;
      drawLineChart(document.getElementById('grassChart'), ts.cumulativeGrassCut, null, 'rgb(34,197,94)', 'Cesped');
      drawLineChart(document.getElementById('scoreChart'), ts.cumulativeScore, null, 'rgb(37,99,235)', 'Puntos');
      drawLineChart(document.getElementById('errorsChart'), ts.cumulativeErrors, null, 'rgb(239,68,68)', 'Errores');
      drawLineChart(document.getElementById('effChart'), ts.movementEfficiency.map(v => Math.round(v * 100)), null, 'rgb(245,158,11)', '%');
      drawBarChart(document.getElementById('rtChart'), clinicalMetrics.reactionTimes, 'Corte #', 'rgb(124,58,237)', 'ms');
      drawBarChart(document.getElementById('pauseChart'), clinicalMetrics.pauseDurations.filter(p => p > 500), 'Pausa #', 'rgb(14,165,233)', 'ms');
    });
  }

  function addChartBlock(title, canvasId) {
    const div = document.createElement('div');
    div.className = 'chart-container';
    div.innerHTML = '<h3>' + title + '</h3><canvas id="' + canvasId + '"></canvas>';
    metricsCharts.appendChild(div);
  }

  function metricItem(label, value) {
    return '<div style="background:#fff; padding:0.4rem 0.6rem; border-radius:6px; border:1px solid #e2e8f0;">'
      + '<span style="color:#64748b;">' + label + ':</span> <strong>' + value + '</strong></div>';
  }

  // ---- GAME INIT ----
  function initGame(level) {
    currentLevel = level;
    levelSelectScreen.classList.remove('hidden');
    levelSelectScreen.classList.add('hidden');
    resultScreen.classList.add('hidden');
    celebCanvas.classList.add('hidden');
    blockedOverlay.classList.add('hidden');
    metricsOverlay.classList.add('hidden');
    isBlocked = false;
    clearInterval(blockedCheckInterval);

    // Reset clinical metrics for new session
    resetClinicalMetrics();
    resetMetricsTimeSeries();

    const { map, startPos } = buildLevel(level);
    grid = map;
    gridH = grid.length;
    gridW = grid[0].length;
    playerX = startPos[1];
    playerY = startPos[0];
    score = 0;
    errors = 0;
    flowersHit = 0;
    poolHits = 0;
    cableStucks = 0;
    grassCut = 0;
    bagCount = 0;
    bagEmptyCount = 0;
    isStuck = false;
    timerSeconds = 0;
    stuckOverlay.classList.add('hidden');

    // Count grass
    totalGrass = 0;
    for (let r = 0; r < gridH; r++)
      for (let c = 0; c < gridW; c++)
        if (grid[r][c] === T.GRASS || grid[r][c] === T.CABLE) totalGrass++;

    // cut starting tile
    if (grid[playerY][playerX] === T.GRASS) {
      grid[playerY][playerX] = T.CUT;
      grassCut++;
      score += 10;
      if (hasBag) bagCount++;
    }

    // Show/hide bag (levels 8+ have bag mechanic)
    if (level >= 8) { hasBag = true; bagStat.style.display = ''; }
    else { hasBag = false; bagStat.style.display = 'none'; }

    // Show/hide pool cleaner (levels with pool cleaning required)
    if (poolCleaningRequired) {
      toolBtn.style.display = 'block';
      hasPoolCleaner = true;
      usingPoolCleaner = false;
      toolBtn.classList.remove('active');
      toolBtn.textContent = 'Limpiador de Piscina';
    } else {
      toolBtn.style.display = 'none';
    }

    // Show/hide watering can (Part 2 levels)
    if (wateringRequired) {
      waterBtn.style.display = 'block';
      hasWateringCan = true;
      usingWateringCan = false;
      waterBtn.classList.remove('watering-active');
      waterBtn.textContent = 'Regadera';
      toolIndicator.style.display = 'block';
      toolIndicator.textContent = 'Herramienta: Cortadora';
    } else {
      waterBtn.style.display = 'none';
      toolIndicator.style.display = 'none';
    }

    // Build level name
    let levelName = '';
    if (level >= 101) {
      const PART2_NAMES = {
        101: 'Jardin Abandonado',
        102: 'Rescate del Jardin',
        103: 'Mansion Descuidada',
        104: 'Hotel de Lujo',
        105: 'Parque Municipal'
      };
      levelName = 'Parte 2 - ' + (level - 100) + ': ' + (PART2_NAMES[level] || 'Jardin');
    } else if (level >= 41) {
      const baseL = level - 40;
      levelName = 'Escala 3 - ' + baseL + ' (Mini)';
    } else if (level >= 21) {
      const baseL = level - 20;
      levelName = 'Escala 2 - ' + baseL + ' (Peque침o)';
    } else {
      const LEVEL_NAMES = [
        '', 'Tutorial', 'Jardin Simple', 'Mas Flores', 'Primera Piscina', 'Piscina Grande',
        'Cables Peligrosos', 'Jardin en L', 'La Compostera', 'Camino Sinuoso', 'Limpieza de Piscina',
        'Jardin Doble', 'Pasajes Estrechos', 'Laberinto', 'Zona de Piscinas', 'Jardin en U',
        'Multizona', 'Zonas Aisladas', 'Experto', 'Prueba de Maestria', 'Gran Maestro'
      ];
      levelName = 'Nivel ' + level + ': ' + (LEVEL_NAMES[level] || 'Jardin ' + level);
    }
    gameTitle.textContent = levelName;

    gameRunning = true;
    startTime = Date.now();
    clearInterval(timerInterval);
    timerInterval = setInterval(() => {
      if (!gameRunning) return;
      timerSeconds++;
      timerDisplay.textContent = formatTime(timerSeconds);
      recordTimeSeriesPoint();
    }, 1000);

    // Start blocked check interval
    clearInterval(blockedCheckInterval);
    blockedCheckInterval = setInterval(() => {
      if (gameRunning && clinicalMetrics.totalMoves > 0) {
        checkBlocked();
      }
    }, 2000);

    // Show restart button
    restartBtn.classList.add('visible');

    updateUI();
    resizeCanvas();
    render();

    startSession(level);
  }

  function formatTime(s) {
    const m = Math.floor(s / 60);
    const sec = s % 60;
    return m + ':' + (sec < 10 ? '0' : '') + sec;
  }

  // ---- CANVAS SIZING ----
  function resizeCanvas() {
    const container = canvasContainer;
    const maxW = container.clientWidth - 16;
    const maxH = container.clientHeight - 16;

    const tileW = Math.floor(maxW / gridW);
    const tileH = Math.floor(maxH / gridH);
    // For scaled levels, allow smaller minimum tile size
    const minTile = currentScale >= 3 ? 8 : (currentScale >= 2 ? 12 : 16);
    const maxTile = currentScale >= 3 ? 24 : (currentScale >= 2 ? 36 : 56);
    const tileSize = Math.max(minTile, Math.min(tileW, tileH, maxTile));

    canvas.width = gridW * tileSize;
    canvas.height = gridH * tileSize;
    canvas.style.width = canvas.width + 'px';
    canvas.style.height = canvas.height + 'px';

    render();
  }

  window.addEventListener('resize', () => { if (gameRunning) resizeCanvas(); });

  // ---- RENDER ----
  function render() {
    if (!gameRunning) return;
    const ts = Math.floor(canvas.width / gridW);

    ctx.clearRect(0, 0, canvas.width, canvas.height);

    for (let r = 0; r < gridH; r++) {
      for (let c = 0; c < gridW; c++) {
        const tile = grid[r][c];
        const x = c * ts;
        const y = r * ts;

        // Base color
        ctx.fillStyle = TILE_COLORS[tile] || '#e2e8f0';
        ctx.fillRect(x, y, ts, ts);

        // Grid lines (subtle)
        ctx.strokeStyle = 'rgba(0,0,0,0.06)';
        ctx.lineWidth = 1;
        ctx.strokeRect(x, y, ts, ts);

        // Draw decorations
        if (tile === T.FLOWER) {
          drawFlower(ctx, x, y, ts, flowerColors[r + ',' + c] || '#f43f5e');
        }
        else if (tile === T.FLOWER_DRY) {
          drawDryFlower(ctx, x, y, ts, flowerColors[r + ',' + c] || '#f43f5e');
        }
        else if (tile === T.FLOWER_WATERED) {
          drawFlower(ctx, x, y, ts, flowerColors[r + ',' + c] || '#f43f5e');
        }
        else if (tile === T.POOL || tile === T.POOL_DIRTY) {
          drawPool(ctx, x, y, ts, tile === T.POOL_DIRTY);
        }
        else if (tile === T.CABLE) {
          const cableKey = r + ',' + c;
          if (!collectedCables.has(cableKey)) {
            drawCable(ctx, x, y, ts);
          }
        }
        else if (tile === T.COMPOST) {
          drawCompost(ctx, x, y, ts);
        }
        else if (tile === T.HOUSE) {
          drawHouse(ctx, x, y, ts);
        }
        else if (tile === T.FENCE) {
          drawFence(ctx, x, y, ts);
        }
        else if (tile === T.CUT) {
          // mow lines
          ctx.strokeStyle = 'rgba(0,100,0,0.12)';
          ctx.lineWidth = 1;
          for (let i = 3; i < ts; i += 5) {
            ctx.beginPath();
            ctx.moveTo(x, y + i);
            ctx.lineTo(x + ts, y + i);
            ctx.stroke();
          }
        }
      }
    }

    // Draw player (mower)
    drawMower(ctx, playerX * ts, playerY * ts, ts);
  }

  function drawFlower(ctx, x, y, ts, color) {
    const cx = x + ts / 2, cy = y + ts / 2;
    const r = ts * 0.15;
    // petals
    ctx.fillStyle = color;
    for (let i = 0; i < 5; i++) {
      const a = (i / 5) * Math.PI * 2 - Math.PI / 2;
      ctx.beginPath();
      ctx.arc(cx + Math.cos(a) * r * 1.2, cy + Math.sin(a) * r * 1.2, r, 0, Math.PI * 2);
      ctx.fill();
    }
    // center
    ctx.fillStyle = '#facc15';
    ctx.beginPath();
    ctx.arc(cx, cy, r * 0.7, 0, Math.PI * 2);
    ctx.fill();
  }

  function drawDryFlower(ctx, x, y, ts, color) {
    const cx = x + ts / 2, cy = y + ts / 2;
    const r = ts * 0.15;
    // wilted petals (brownish version of original color)
    ctx.fillStyle = '#a8856a'; // dried flower color
    for (let i = 0; i < 5; i++) {
      const a = (i / 5) * Math.PI * 2 - Math.PI / 2;
      ctx.beginPath();
      // slightly droopy/irregular shape
      ctx.arc(cx + Math.cos(a) * r * 1.1, cy + Math.sin(a) * r * 1.3, r * 0.85, 0, Math.PI * 2);
      ctx.fill();
    }
    // dried center
    ctx.fillStyle = '#8b7355';
    ctx.beginPath();
    ctx.arc(cx, cy, r * 0.6, 0, Math.PI * 2);
    ctx.fill();
    // water drop indicator
    ctx.fillStyle = '#38bdf8';
    ctx.beginPath();
    ctx.arc(cx + ts * 0.25, cy - ts * 0.2, ts * 0.08, 0, Math.PI * 2);
    ctx.fill();
  }

  function drawPool(ctx, x, y, ts, dirty) {
    // water ripples
    ctx.strokeStyle = dirty ? 'rgba(180,140,60,0.3)' : 'rgba(255,255,255,0.35)';
    ctx.lineWidth = 1.5;
    ctx.beginPath();
    ctx.moveTo(x + ts * 0.2, y + ts * 0.4);
    ctx.quadraticCurveTo(x + ts * 0.5, y + ts * 0.25, x + ts * 0.8, y + ts * 0.4);
    ctx.stroke();
    ctx.beginPath();
    ctx.moveTo(x + ts * 0.15, y + ts * 0.65);
    ctx.quadraticCurveTo(x + ts * 0.5, y + ts * 0.5, x + ts * 0.85, y + ts * 0.65);
    ctx.stroke();
    if (dirty) {
      ctx.fillStyle = 'rgba(120,80,20,0.2)';
      ctx.fillRect(x + 2, y + 2, ts - 4, ts - 4);
    }
  }

  function drawCable(ctx, x, y, ts) {
    ctx.strokeStyle = '#1e293b';
    ctx.lineWidth = 3;
    ctx.setLineDash([4, 3]);
    ctx.beginPath();
    ctx.moveTo(x + ts * 0.1, y + ts * 0.5);
    ctx.bezierCurveTo(x + ts * 0.3, y + ts * 0.2, x + ts * 0.7, y + ts * 0.8, x + ts * 0.9, y + ts * 0.5);
    ctx.stroke();
    ctx.setLineDash([]);
    // plug icon
    ctx.fillStyle = '#334155';
    ctx.fillRect(x + ts * 0.82, y + ts * 0.38, ts * 0.12, ts * 0.24);
  }

  function drawCompost(ctx, x, y, ts) {
    // bin shape
    ctx.fillStyle = '#78350f';
    const bx = x + ts * 0.2, by = y + ts * 0.15, bw = ts * 0.6, bh = ts * 0.7;
    ctx.fillRect(bx, by, bw, bh);
    ctx.fillStyle = '#a16207';
    ctx.fillRect(bx + 2, by + 2, bw - 4, ts * 0.15);
    // leaves
    ctx.fillStyle = '#22c55e';
    ctx.beginPath();
    ctx.arc(x + ts * 0.4, y + ts * 0.55, ts * 0.08, 0, Math.PI * 2);
    ctx.arc(x + ts * 0.6, y + ts * 0.5, ts * 0.07, 0, Math.PI * 2);
    ctx.fill();
  }

  function drawHouse(ctx, x, y, ts) {
    ctx.fillStyle = '#8d6e63';
    ctx.fillRect(x, y, ts, ts);
    ctx.fillStyle = '#6d4c41';
    ctx.fillRect(x + ts * 0.2, y + ts * 0.3, ts * 0.25, ts * 0.35);
    ctx.fillStyle = '#90caf9';
    ctx.fillRect(x + ts * 0.55, y + ts * 0.25, ts * 0.3, ts * 0.25);
  }

  function drawFence(ctx, x, y, ts) {
    ctx.fillStyle = '#475569';
    ctx.fillRect(x, y, ts, ts);
    ctx.fillStyle = '#334155';
    ctx.fillRect(x + ts * 0.1, y, ts * 0.15, ts);
    ctx.fillRect(x + ts * 0.75, y, ts * 0.15, ts);
    ctx.fillStyle = '#64748b';
    ctx.fillRect(x, y + ts * 0.25, ts, ts * 0.12);
    ctx.fillRect(x, y + ts * 0.65, ts, ts * 0.12);
  }

  function drawMower(ctx, x, y, ts) {
    const m = ts * 0.1;

    // Determine tool color
    let bodyColor, handleColor;
    if (usingWateringCan) {
      bodyColor = '#059669'; // green for watering can
      handleColor = '#047857';
    } else if (usingPoolCleaner) {
      bodyColor = '#0891b2'; // cyan for pool cleaner
      handleColor = '#155e75';
    } else {
      bodyColor = '#dc2626'; // red for mower
      handleColor = '#991b1b';
    }

    // Body
    ctx.fillStyle = bodyColor;
    ctx.beginPath();
    ctx.roundRect(x + m, y + m, ts - m * 2, ts - m * 2, ts * 0.15);
    ctx.fill();
    // Handle
    ctx.fillStyle = handleColor;
    ctx.fillRect(x + ts * 0.42, y + m - ts * 0.06, ts * 0.16, ts * 0.15);
    // Wheels
    ctx.fillStyle = '#1e293b';
    const wr = ts * 0.08;
    ctx.beginPath();
    ctx.arc(x + ts * 0.25, y + ts * 0.22, wr, 0, Math.PI * 2);
    ctx.arc(x + ts * 0.75, y + ts * 0.22, wr, 0, Math.PI * 2);
    ctx.arc(x + ts * 0.25, y + ts * 0.78, wr, 0, Math.PI * 2);
    ctx.arc(x + ts * 0.75, y + ts * 0.78, wr, 0, Math.PI * 2);
    ctx.fill();

    // Tool-specific icon
    if (usingWateringCan) {
      // Water drops
      ctx.fillStyle = '#38bdf8';
      ctx.beginPath();
      ctx.arc(x + ts * 0.4, y + ts * 0.5, ts * 0.06, 0, Math.PI * 2);
      ctx.arc(x + ts * 0.6, y + ts * 0.55, ts * 0.05, 0, Math.PI * 2);
      ctx.arc(x + ts * 0.5, y + ts * 0.65, ts * 0.05, 0, Math.PI * 2);
      ctx.fill();
    } else {
      // Blade lines
      ctx.strokeStyle = 'rgba(255,255,255,0.5)';
      ctx.lineWidth = 1.5;
      ctx.beginPath();
      ctx.moveTo(x + ts * 0.3, y + ts * 0.5);
      ctx.lineTo(x + ts * 0.7, y + ts * 0.5);
      ctx.stroke();
    }
  }

  // ---- UI UPDATE ----
  function updateUI() {
    scoreDisplay.textContent = score;
    errorsDisplay.textContent = errors;
    grassDisplay.textContent = grassCut + '/' + totalGrass;
    if (hasBag) {
      bagDisplay.textContent = bagCount + '/' + bagCapacity;
      bagStat.className = 'stat stat-bag' + (bagCount >= bagCapacity ? ' bag-full' : '');
    }
  }

  // ---- MOVEMENT ----
  function movePlayer(dx, dy) {
    if (!gameRunning || isStuck) return;

    const timestamp = Date.now();
    const nx = playerX + dx;
    const ny = playerY + dy;

    // Bounds check
    if (ny < 0 || ny >= gridH || nx < 0 || nx >= gridW) {
      recordMovement(dx, dy, false, timestamp); // Invalid move - bounds
      return;
    }

    const tile = grid[ny][nx];

    // Impassable
    if (tile === T.FENCE || tile === T.HOUSE || tile === T.EMPTY) {
      recordMovement(dx, dy, false, timestamp); // Invalid move - obstacle
      return;
    }

    // Pool collision
    if (tile === T.POOL) {
      errors++;
      poolHits++;
      score -= 100;
      showToast('Caiste en la piscina! -100 pts', 'error');
      metricsTimeSeries.commissionEvents.push({ time: Math.floor((Date.now() - startTime) / 1000), type: 'pool' });
      recordMovement(dx, dy, false, timestamp); // Commission error
      updateUI();
      render();
      return;
    }

    // Pool dirty - need pool cleaner
    if (tile === T.POOL_DIRTY) {
      if (usingPoolCleaner) {
        grid[ny][nx] = T.POOL; // cleaned!
        playerX = nx;
        playerY = ny;
        showToast('Piscina limpiada!', 'info');
        recordMovement(dx, dy, true, timestamp);
        // check if all dirty cleaned
        let dirtyLeft = false;
        for (let r = 0; r < gridH; r++)
          for (let c = 0; c < gridW; c++)
            if (grid[r][c] === T.POOL_DIRTY) dirtyLeft = true;
        if (!dirtyLeft) {
          showToast('Toda la piscina esta limpia! Vuelve a la cortadora.', 'info', 3000);
        }
        updateUI();
        render();
        return;
      } else {
        showToast('Necesitas el limpiador de piscina!', 'warn');
        recordMovement(dx, dy, false, timestamp);
        return;
      }
    }

    // Can't mow while using pool cleaner
    if (usingPoolCleaner && (tile === T.GRASS || tile === T.FLOWER || tile === T.FLOWER_DRY)) {
      showToast('Cambia a la cortadora para cortar cesped!', 'warn');
      recordMovement(dx, dy, false, timestamp);
      return;
    }

    // Can't mow while using watering can
    if (usingWateringCan && (tile === T.GRASS || tile === T.FLOWER)) {
      showToast('Cambia a la cortadora para cortar cesped!', 'warn');
      recordMovement(dx, dy, false, timestamp);
      return;
    }

    // Dry flowers - need watering can
    if (tile === T.FLOWER_DRY) {
      if (usingWateringCan) {
        grid[ny][nx] = T.FLOWER_WATERED; // watered!
        flowersWatered++;
        score += 25;
        playerX = nx;
        playerY = ny;
        showToast('Flor regada! +25 pts', 'info');
        recordMovement(dx, dy, true, timestamp);
        // check if all watered
        let dryLeft = false;
        for (let r = 0; r < gridH; r++)
          for (let c = 0; c < gridW; c++)
            if (grid[r][c] === T.FLOWER_DRY) dryLeft = true;
        if (!dryLeft) {
          showToast('Todas las flores regadas!', 'info', 3000);
        }
        updateUI();
        render();
        checkWin();
        return;
      } else {
        showToast('Necesitas la regadera para regar flores!', 'warn');
        recordMovement(dx, dy, false, timestamp);
        return;
      }
    }

    // Watered flowers - can walk on them but don't destroy
    if (tile === T.FLOWER_WATERED) {
      playerX = nx;
      playerY = ny;
      recordMovement(dx, dy, true, timestamp);
      updateUI();
      render();
      return;
    }

    // Bag full check
    if (hasBag && bagCount >= bagCapacity && tile === T.GRASS) {
      showToast('Bolsa llena! Ve a la compostera para vaciar.', 'warn');
      metricsTimeSeries.bagFullEvents.push({ time: Math.floor((Date.now() - startTime) / 1000) });
      recordMovement(dx, dy, false, timestamp);
      // Still allow movement onto non-grass
      return;
    }

    // Cable check
    if (tile === T.CABLE) {
      const key = ny + ',' + nx;
      if (!collectedCables.has(key)) {
        // get stuck
        isStuck = true;
        cableStucks++;
        errors++;
        score -= 20;
        showToast('Atascado en un cable! -20 pts', 'error');
        stuckOverlay.classList.remove('hidden');
        recordMovement(dx, dy, false, timestamp); // Commission error
        updateUI();
        clearTimeout(stuckTimer);
        stuckTimer = setTimeout(() => {
          isStuck = false;
          stuckOverlay.classList.add('hidden');
          collectedCables.add(key);
          // now treat as grass
          grid[ny][nx] = T.CUT;
          grassCut++;
          recordGrassCut(); // Record timing for RTV
          score += 10;
          if (hasBag) bagCount++;
          playerX = nx;
          playerY = ny;
          updateUI();
          render();
          checkWin();
        }, 2000);
        return;
      } else {
        // already collected, treat as cut grass
        playerX = nx;
        playerY = ny;
        recordMovement(dx, dy, true, timestamp);
        updateUI();
        render();
        return;
      }
    }

    // Flower
    if (tile === T.FLOWER) {
      errors++;
      flowersHit++;
      score -= 50;
      grid[ny][nx] = T.CUT; // destroyed
      showToast('Flor destruida! -50 pts', 'error');
      metricsTimeSeries.commissionEvents.push({ time: Math.floor((Date.now() - startTime) / 1000), type: 'flower' });
      playerX = nx;
      playerY = ny;
      recordMovement(dx, dy, true, timestamp); // Commission error - successful move but wrong target
      updateUI();
      render();
      return;
    }

    // Compost bin
    if (tile === T.COMPOST) {
      if (hasBag && bagCount > 0) {
        bagEmptyCount++;
        bagCount = 0;
        showToast('Bolsa vaciada en la compostera!', 'info');
      }
      playerX = nx;
      playerY = ny;
      recordMovement(dx, dy, true, timestamp);
      updateUI();
      render();
      return;
    }

    // Grass
    if (tile === T.GRASS) {
      grid[ny][nx] = T.CUT;
      grassCut++;
      recordGrassCut(); // Record timing for RTV
      score += 10;
      if (hasBag) bagCount++;
    }

    // PATH or CUT - just move
    playerX = nx;
    playerY = ny;
    recordMovement(dx, dy, true, timestamp);
    updateUI();
    render();
    checkWin();
  }

  // ---- CABLE CLICK/TAP (collect cables) ----
  canvas.addEventListener('click', handleCanvasClick);
  canvas.addEventListener('touchend', function(e) {
    e.preventDefault();
    const rect = canvas.getBoundingClientRect();
    const touch = e.changedTouches[0];
    handleCanvasClickAt(touch.clientX - rect.left, touch.clientY - rect.top);
  });

  function handleCanvasClick(e) {
    const rect = canvas.getBoundingClientRect();
    handleCanvasClickAt(e.clientX - rect.left, e.clientY - rect.top);
  }

  function handleCanvasClickAt(cx, cy) {
    if (!gameRunning) return;
    const ts = Math.floor(canvas.width / gridW);
    const col = Math.floor(cx / ts);
    const row = Math.floor(cy / ts);
    if (row < 0 || row >= gridH || col < 0 || col >= gridW) return;

    if (grid[row][col] === T.CABLE) {
      const key = row + ',' + col;
      if (!collectedCables.has(key)) {
        // Must be adjacent to player
        const dist = Math.abs(row - playerY) + Math.abs(col - playerX);
        if (dist <= 2) {
          collectedCables.add(key);
          showToast('Cable recogido!', 'info');
          render();
        } else {
          showToast('Acercate mas al cable para recogerlo.', 'warn');
        }
      }
    }
  }

  // ---- WIN CHECK ----
  function checkWin() {
    if (grassCut >= totalGrass) {
      // Check pool dirty tiles too
      if (poolCleaningRequired) {
        for (let r = 0; r < gridH; r++)
          for (let c = 0; c < gridW; c++)
            if (grid[r][c] === T.POOL_DIRTY) {
              showToast('Falta limpiar la piscina!', 'warn');
              return;
            }
      }
      // Check dry flowers for Part 2
      if (wateringRequired) {
        for (let r = 0; r < gridH; r++)
          for (let c = 0; c < gridW; c++)
            if (grid[r][c] === T.FLOWER_DRY) {
              showToast('Falta regar las flores!', 'warn');
              return;
            }
      }
      gameWin();
    }
  }

  function gameWin() {
    gameRunning = false;
    clearInterval(timerInterval);
    clearInterval(blockedCheckInterval);
    restartBtn.classList.remove('visible');

    // Bonuses
    const completionBonus = 500;
    const speedBonus = Math.max(0, 300 - timerSeconds);
    score += completionBonus + speedBonus;

    // Record final time series point
    recordTimeSeriesPoint();

    showResultScreen(true, completionBonus, speedBonus);
    showCelebration();
    saveResult(true);
  }

  function showResultScreen(won, completionBonus, speedBonus) {
    resultScreen.classList.remove('hidden');
    resultTitle.textContent = won ? 'Completado! Muy bien!' : 'Juego terminado';
    resultTitle.className = 'result-title ' + (won ? 'win' : 'lose');

    // Show/hide next level button
    const nextLevel = getNextLevel(currentLevel);
    if (won && nextLevel) {
      nextLevelBtn.classList.remove('hidden');
      nextLevelBtn.style.display = '';
    } else {
      nextLevelBtn.classList.add('hidden');
      nextLevelBtn.style.display = 'none';
    }

    completionBonus = completionBonus || 0;
    speedBonus = speedBonus || 0;

    const grassPts = grassCut * 10;
    const flowerPenalty = flowersHit * 50;
    const poolPenalty = poolHits * 100;
    const cablePenalty = cableStucks * 20;
    const wateringBonus = flowersWatered * 25;
    const maxScore = totalGrass * 10 + 500 + 300 + (totalDryFlowers * 25);

    let html = '';
    html += scoreRow('Cesped cortado (' + grassCut + '/' + totalGrass + ')', '+' + grassPts, true);
    if (flowersWatered > 0) html += scoreRow('Flores regadas (x' + flowersWatered + ')', '+' + wateringBonus, true);
    if (won) html += scoreRow('Bonus por completar', '+' + completionBonus, true);
    if (won) html += scoreRow('Bonus por velocidad', '+' + speedBonus, speedBonus > 0);
    if (flowersHit > 0) html += scoreRow('Flores destruidas (x' + flowersHit + ')', '-' + flowerPenalty, false);
    if (poolHits > 0) html += scoreRow('Caidas a piscina (x' + poolHits + ')', '-' + poolPenalty, false);
    if (cableStucks > 0) html += scoreRow('Atascado en cables (x' + cableStucks + ')', '-' + cablePenalty, false);
    html += '<div class="score-row total"><span>Puntuacion final</span><span class="pts ' + (score >= 0 ? 'positive' : 'negative') + '">' + score + ' / ' + maxScore + '</span></div>';
    html += '<div class="score-row"><span>Tiempo</span><span>' + formatTime(timerSeconds) + '</span></div>';
    if (hasBag) html += '<div class="score-row"><span>Vaciados de bolsa</span><span>' + bagEmptyCount + '</span></div>';

    scoreBreakdown.innerHTML = html;
  }

  function scoreRow(label, pts, positive) {
    return '<div class="score-row"><span>' + label + '</span><span class="pts ' + (positive ? 'positive' : 'negative') + '">' + pts + '</span></div>';
  }

  // ---- CELEBRATION ----
  let particles = [];
  let celebAnimId = null;

  function showCelebration() {
    celebCanvas.classList.remove('hidden');
    celebCanvas.width = window.innerWidth;
    celebCanvas.height = window.innerHeight;
    particles = [];
    const colors = ['#2563eb','#10b981','#f59e0b','#ef4444','#8b5cf6','#ec4899','#06b6d4'];
    for (let i = 0; i < 100; i++) {
      particles.push({
        x: Math.random() * celebCanvas.width,
        y: -Math.random() * celebCanvas.height * 0.5,
        vx: (Math.random() - 0.5) * 4,
        vy: Math.random() * 3 + 2,
        size: Math.random() * 8 + 3,
        color: colors[Math.floor(Math.random() * colors.length)],
        rot: Math.random() * 360,
        vr: (Math.random() - 0.5) * 10
      });
    }
    animateCelebration();
  }

  function animateCelebration() {
    celebCtx.clearRect(0, 0, celebCanvas.width, celebCanvas.height);
    let alive = false;
    for (const p of particles) {
      p.x += p.vx;
      p.y += p.vy;
      p.vy += 0.05;
      p.rot += p.vr;
      if (p.y < celebCanvas.height + 20) alive = true;
      celebCtx.save();
      celebCtx.translate(p.x, p.y);
      celebCtx.rotate(p.rot * Math.PI / 180);
      celebCtx.fillStyle = p.color;
      celebCtx.fillRect(-p.size / 2, -p.size / 2, p.size, p.size * 0.6);
      celebCtx.restore();
    }
    if (alive) {
      celebAnimId = requestAnimationFrame(animateCelebration);
    } else {
      celebCanvas.classList.add('hidden');
    }
  }

  // ---- KEYBOARD INPUT ----
  document.addEventListener('keydown', function(e) {
    if (!gameRunning) return;
    recordInputMethod('keyboard');
    switch (e.key) {
      case 'ArrowUp': case 'w': case 'W': e.preventDefault(); movePlayer(0, -1); break;
      case 'ArrowDown': case 's': case 'S': e.preventDefault(); movePlayer(0, 1); break;
      case 'ArrowLeft': case 'a': case 'A': e.preventDefault(); movePlayer(-1, 0); break;
      case 'ArrowRight': case 'd': case 'D': e.preventDefault(); movePlayer(1, 0); break;
    }
  });

  // ---- D-PAD ----
  document.querySelectorAll('.dpad-btn').forEach(btn => {
    function handler(e) {
      e.preventDefault();
      e.stopPropagation();
      recordInputMethod('touch');
      const dir = btn.getAttribute('data-dir');
      if (dir === 'up') movePlayer(0, -1);
      else if (dir === 'down') movePlayer(0, 1);
      else if (dir === 'left') movePlayer(-1, 0);
      else if (dir === 'right') movePlayer(1, 0);
    }
    btn.addEventListener('click', handler);
    btn.addEventListener('touchstart', function(e) {
      e.preventDefault();
      e.stopPropagation();
      handler(e);
    }, { passive: false });
    btn.addEventListener('touchend', function(e) {
      e.preventDefault();
      e.stopPropagation();
    }, { passive: false });
  });

  // ---- TOOL BUTTON ----
  toolBtn.addEventListener('click', function() {
    if (!gameRunning) return;
    usingPoolCleaner = !usingPoolCleaner;
    usingWateringCan = false; // Deactivate watering can
    waterBtn.classList.remove('watering-active');
    waterBtn.textContent = 'Regadera';
    if (usingPoolCleaner) {
      toolBtn.classList.add('active');
      toolBtn.textContent = 'Cortadora de Cesped';
      toolIndicator.textContent = 'Herramienta: Limpiador';
      showToast('Cambiaste al limpiador de piscina', 'info');
    } else {
      toolBtn.classList.remove('active');
      toolBtn.textContent = 'Limpiador de Piscina';
      toolIndicator.textContent = 'Herramienta: Cortadora';
      showToast('Cambiaste a la cortadora de cesped', 'info');
    }
    render();
  });

  // ---- WATERING CAN BUTTON ----
  waterBtn.addEventListener('click', function() {
    if (!gameRunning) return;
    usingWateringCan = !usingWateringCan;
    usingPoolCleaner = false; // Deactivate pool cleaner
    toolBtn.classList.remove('active');
    toolBtn.textContent = 'Limpiador de Piscina';
    if (usingWateringCan) {
      waterBtn.classList.add('watering-active');
      waterBtn.textContent = 'Cortadora de Cesped';
      toolIndicator.textContent = 'Herramienta: Regadera';
      showToast('Cambiaste a la regadera', 'info');
    } else {
      waterBtn.classList.remove('watering-active');
      waterBtn.textContent = 'Regadera';
      toolIndicator.textContent = 'Herramienta: Cortadora';
      showToast('Cambiaste a la cortadora de cesped', 'info');
    }
    render();
  });

  // ---- LEVEL SELECT ----
  document.querySelectorAll('.level-btn').forEach(btn => {
    btn.addEventListener('click', function() {
      const level = parseInt(this.getAttribute('data-level'));
      levelSelectScreen.classList.add('hidden');
      showInstructions(level, function() {
        initGame(level);
      });
    });
  });

  // ---- RESULT BUTTONS ----
  document.getElementById('retryBtn').addEventListener('click', function() {
    cancelAnimationFrame(celebAnimId);
    celebCanvas.classList.add('hidden');
    initGame(currentLevel);
  });
  nextLevelBtn.addEventListener('click', function() {
    cancelAnimationFrame(celebAnimId);
    celebCanvas.classList.add('hidden');
    resultScreen.classList.add('hidden');
    const next = getNextLevel(currentLevel);
    if (next) {
      showInstructions(next, function() {
        initGame(next);
      });
    }
  });
  metricsBtn.addEventListener('click', function() {
    showMetricsPanel();
  });
  metricsCloseBtn.addEventListener('click', function() {
    metricsOverlay.classList.add('hidden');
  });
  document.getElementById('levelsBtn').addEventListener('click', function() {
    cancelAnimationFrame(celebAnimId);
    celebCanvas.classList.add('hidden');
    resultScreen.classList.add('hidden');
    gameRunning = false;
    clearInterval(timerInterval);
    clearInterval(blockedCheckInterval);
    restartBtn.classList.remove('visible');
    levelSelectScreen.classList.remove('hidden');
  });

  // ---- RESTART BUTTON (in-game) ----
  restartBtn.addEventListener('click', function() {
    if (gameRunning || isBlocked) {
      if (grassCut > 0) saveResult(false);
      cancelAnimationFrame(celebAnimId);
      celebCanvas.classList.add('hidden');
      initGame(currentLevel);
    }
  });
  blockedRestartBtn.addEventListener('click', function() {
    saveResult(false);
    cancelAnimationFrame(celebAnimId);
    celebCanvas.classList.add('hidden');
    blockedOverlay.classList.add('hidden');
    initGame(currentLevel);
  });

  // ---- BACK BUTTON (save on quit) ----
  document.getElementById('backBtn').addEventListener('click', function(e) {
    if (gameRunning && grassCut > 0) {
      saveResult(false);
    }
  });

  // ---- SWIPE SUPPORT (Touch) ----
  let touchStartX = 0, touchStartY = 0;
  let touchStartTime = 0;
  canvas.addEventListener('touchstart', function(e) {
    if (e.touches.length === 1) {
      touchStartX = e.touches[0].clientX;
      touchStartY = e.touches[0].clientY;
      touchStartTime = Date.now();
    }
  }, { passive: true });
  canvas.addEventListener('touchmove', function(e) { e.preventDefault(); }, { passive: false });
  canvas.addEventListener('touchend', function(e) {
    // Only handle swipe if it's clearly a swipe (not a tap for cable)
    const dx = e.changedTouches[0].clientX - touchStartX;
    const dy = e.changedTouches[0].clientY - touchStartY;
    const dist = Math.sqrt(dx * dx + dy * dy);
    const elapsed = Date.now() - touchStartTime;

    // If it's a quick tap (less than 200ms and small movement), handle as click for cable collection
    if (elapsed < 200 && dist < 20) {
      return; // Let the click handler deal with it
    }

    // If it's a swipe (more movement), handle as movement
    if (dist >= 20) {
      e.preventDefault();
      recordInputMethod('touch');
      if (Math.abs(dx) > Math.abs(dy)) {
        movePlayer(dx > 0 ? 1 : -1, 0);
      } else {
        movePlayer(0, dy > 0 ? 1 : -1);
      }
    }
  });

  // ---- MOUSE DRAG SUPPORT (PC) ----
  // Allows players to click and drag with right mouse button to move
  let mouseDown = false;
  let mouseStartX = 0, mouseStartY = 0;
  let lastMoveTime = 0;
  const MOUSE_MOVE_THRESHOLD = 25; // pixels needed to trigger movement
  const MOUSE_MOVE_COOLDOWN = 150; // ms between movements for smooth control

  canvas.addEventListener('mousedown', function(e) {
    // Right-click (button 2) or middle-click (button 1) for drag movement
    if (e.button === 2 || e.button === 1) {
      e.preventDefault();
      recordInputMethod('mouse');
      mouseDown = true;
      mouseStartX = e.clientX;
      mouseStartY = e.clientY;
      canvas.style.cursor = 'grabbing';
    }
  });

  canvas.addEventListener('mousemove', function(e) {
    if (!mouseDown || !gameRunning) return;

    const now = Date.now();
    if (now - lastMoveTime < MOUSE_MOVE_COOLDOWN) return;

    const dx = e.clientX - mouseStartX;
    const dy = e.clientY - mouseStartY;
    const dist = Math.sqrt(dx * dx + dy * dy);

    if (dist >= MOUSE_MOVE_THRESHOLD) {
      // Determine primary direction
      if (Math.abs(dx) > Math.abs(dy)) {
        movePlayer(dx > 0 ? 1 : -1, 0);
      } else {
        movePlayer(0, dy > 0 ? 1 : -1);
      }
      // Reset start position for continuous movement
      mouseStartX = e.clientX;
      mouseStartY = e.clientY;
      lastMoveTime = now;
    }
  });

  canvas.addEventListener('mouseup', function(e) {
    if (e.button === 2 || e.button === 1) {
      mouseDown = false;
      canvas.style.cursor = 'default';
    }
  });

  canvas.addEventListener('mouseleave', function() {
    mouseDown = false;
    canvas.style.cursor = 'default';
  });

  // Prevent context menu on right-click on canvas
  canvas.addEventListener('contextmenu', function(e) {
    e.preventDefault();
  });

  // ---- roundRect polyfill ----
  if (!CanvasRenderingContext2D.prototype.roundRect) {
    CanvasRenderingContext2D.prototype.roundRect = function(x, y, w, h, r) {
      if (typeof r === 'number') r = [r, r, r, r];
      this.moveTo(x + r[0], y);
      this.lineTo(x + w - r[1], y);
      this.quadraticCurveTo(x + w, y, x + w, y + r[1]);
      this.lineTo(x + w, y + h - r[2]);
      this.quadraticCurveTo(x + w, y + h, x + w - r[2], y + h);
      this.lineTo(x + r[3], y + h);
      this.quadraticCurveTo(x, y + h, x, y + h - r[3]);
      this.lineTo(x, y + r[0]);
      this.quadraticCurveTo(x, y, x + r[0], y);
      this.closePath();
    };
  }

  // Show level select on load
  levelSelectScreen.classList.remove('hidden');

})();
</script>
</body>
</html>
