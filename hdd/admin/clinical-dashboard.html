<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dashboard ClÃ­nico | HDD Profesional</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4"></script>
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
    <style>
        * { margin:0; padding:0; box-sizing:border-box; }
        body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; background: #0f172a; color: #e2e8f0; min-height: 100vh; }
        .dashboard { max-width: 1300px; margin: 0 auto; padding: 1.5rem; }
        .dash-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 1.5rem; flex-wrap: wrap; gap: 1rem; border-bottom: 1px solid rgba(255,255,255,0.1); padding-bottom: 1rem; }
        .dash-header h1 { font-size: 1.3rem; color: #60a5fa; }
        .dash-header h1 span { color: #f87171; font-size: 0.7rem; background: rgba(248,113,113,0.15); padding: 2px 8px; border-radius: 4px; vertical-align: middle; margin-left: 8px; }
        .back-btn { color: rgba(255,255,255,0.5); text-decoration: none; font-size: 0.85rem; padding: 0.5rem 1rem; border: 1px solid rgba(255,255,255,0.15); border-radius: 6px; }
        .back-btn:hover { background: rgba(255,255,255,0.08); color: #fff; }

        /* Auth gate */
        .auth-gate { text-align: center; padding: 4rem 1rem; }
        .auth-gate h2 { color: #f87171; margin-bottom: 1rem; }
        .auth-gate a { color: #60a5fa; }

        /* Patient selector */
        .patient-selector { display: flex; gap: 1rem; align-items: center; margin-bottom: 1.5rem; flex-wrap: wrap; }
        .patient-selector select { background: rgba(255,255,255,0.08); color: #fff; border: 1px solid rgba(255,255,255,0.2); padding: 0.6rem 1rem; border-radius: 8px; font-size: 0.9rem; min-width: 280px; }
        .patient-selector select option { background: #1e293b; }
        .patient-info-bar { font-size: 0.85rem; color: rgba(255,255,255,0.5); }

        /* Summary cards */
        .summary-row { display: grid; grid-template-columns: repeat(auto-fit, minmax(130px, 1fr)); gap: 0.7rem; margin-bottom: 1.5rem; }
        .summary-card { background: rgba(255,255,255,0.06); border-radius: 10px; padding: 0.9rem; text-align: center; border: 1px solid rgba(255,255,255,0.08); }
        .summary-card .val { font-size: 1.6rem; font-weight: 700; color: #fff; }
        .summary-card .lbl { font-size: 0.65rem; color: rgba(255,255,255,0.4); text-transform: uppercase; letter-spacing: 0.5px; margin-top: 0.2rem; }

        /* Game tabs */
        .game-tabs { display: flex; gap: 0.5rem; margin-bottom: 1.5rem; flex-wrap: wrap; }
        .game-tab { padding: 0.5rem 1rem; border-radius: 8px; background: rgba(255,255,255,0.06); color: rgba(255,255,255,0.5); cursor: pointer; border: 1px solid transparent; font-size: 0.85rem; transition: all 0.2s; }
        .game-tab:hover { background: rgba(255,255,255,0.1); }
        .game-tab.active { background: rgba(96,165,250,0.15); color: #60a5fa; border-color: rgba(96,165,250,0.3); }

        /* Charts */
        .charts-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 1.2rem; margin-bottom: 1.5rem; }
        .chart-box { background: rgba(255,255,255,0.04); border-radius: 12px; padding: 1rem; border: 1px solid rgba(255,255,255,0.06); }
        .chart-box h3 { font-size: 0.85rem; color: rgba(255,255,255,0.5); margin-bottom: 0.6rem; }
        .chart-box canvas { max-height: 260px; }
        .chart-box.full { grid-column: 1 / -1; }

        /* Color mood timeline */
        .mood-timeline { display: flex; flex-wrap: wrap; gap: 4px; margin-bottom: 1.5rem; }
        .mood-dot { width: 28px; height: 28px; border-radius: 50%; border: 2px solid rgba(255,255,255,0.1); cursor: pointer; position: relative; }
        .mood-dot:hover { transform: scale(1.3); border-color: rgba(255,255,255,0.4); }
        .mood-dot .tooltip { display: none; position: absolute; bottom: 110%; left: 50%; transform: translateX(-50%); background: #1e293b; color: #fff; padding: 4px 8px; border-radius: 4px; font-size: 0.7rem; white-space: nowrap; z-index: 10; }
        .mood-dot:hover .tooltip { display: block; }

        /* Sessions table */
        .sessions-table { width: 100%; border-collapse: collapse; font-size: 0.78rem; }
        .sessions-table th { text-align: left; padding: 0.5rem; color: rgba(255,255,255,0.4); border-bottom: 1px solid rgba(255,255,255,0.1); font-weight: 600; text-transform: uppercase; font-size: 0.65rem; letter-spacing: 0.5px; }
        .sessions-table td { padding: 0.5rem; border-bottom: 1px solid rgba(255,255,255,0.04); color: rgba(255,255,255,0.7); }
        .sessions-table tr:hover td { background: rgba(255,255,255,0.03); }

        .loading { text-align: center; padding: 4rem; color: rgba(255,255,255,0.4); }
        .no-data { text-align: center; padding: 3rem; color: rgba(255,255,255,0.3); font-style: italic; }
        .section-title { font-size: 1rem; color: rgba(255,255,255,0.6); margin: 1.5rem 0 0.8rem; }

        @media (max-width: 768px) {
            .charts-grid { grid-template-columns: 1fr; }
            .summary-row { grid-template-columns: repeat(3, 1fr); }
        }

        /* Biometric profile radar */
        .profile-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 1.2rem; margin-bottom: 1.5rem; }
        @media (max-width: 768px) { .profile-grid { grid-template-columns: 1fr; } }

        /* Neurocognitive domain cards */
        .domain-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(210px, 1fr)); gap: 0.8rem; margin-bottom: 1.5rem; }
        .domain-card { background: rgba(255,255,255,0.04); border: 1px solid rgba(255,255,255,0.08); border-radius: 12px; padding: 1rem; }
        .domain-card-header { display: flex; align-items: center; gap: 0.5rem; margin-bottom: 0.7rem; }
        .domain-icon { font-size: 1.2rem; }
        .domain-name { font-size: 0.78rem; font-weight: 700; color: rgba(255,255,255,0.7); text-transform: uppercase; letter-spacing: 0.05em; }
        .domain-metric-row { display: flex; justify-content: space-between; align-items: center; font-size: 0.75rem; padding: 0.2rem 0; border-bottom: 1px solid rgba(255,255,255,0.04); }
        .domain-metric-row:last-child { border-bottom: none; }
        .domain-metric-lbl { color: rgba(255,255,255,0.4); }
        .domain-metric-val { color: #fff; font-weight: 600; font-variant-numeric: tabular-nums; }
        .domain-metric-val.good  { color: #34d399; }
        .domain-metric-val.warn  { color: #fbbf24; }
        .domain-metric-val.bad   { color: #f87171; }
        .domain-no-data { font-size: 0.72rem; color: rgba(255,255,255,0.2); font-style: italic; }

        /* Clinical annotation panel */
        .annotation-panel { background: rgba(255,255,255,0.04); border: 1px solid rgba(255,255,255,0.08); border-radius: 12px; padding: 1.1rem; margin-bottom: 1.5rem; }
        .annotation-panel h3 { font-size: 0.85rem; color: rgba(255,255,255,0.5); margin-bottom: 0.8rem; }
        .annotation-form { display: flex; flex-wrap: wrap; gap: 0.6rem; align-items: flex-end; }
        .annotation-form select, .annotation-form input { background: rgba(255,255,255,0.08); color: #fff; border: 1px solid rgba(255,255,255,0.15); padding: 0.45rem 0.75rem; border-radius: 6px; font-size: 0.82rem; }
        .annotation-form select option { background: #1e293b; }
        .annotation-btn { background: rgba(96,165,250,0.2); color: #60a5fa; border: 1px solid rgba(96,165,250,0.3); border-radius: 6px; padding: 0.45rem 1rem; font-size: 0.82rem; cursor: pointer; }
        .annotation-btn:hover { background: rgba(96,165,250,0.35); }
        .annotation-list { margin-top: 0.8rem; display: flex; flex-wrap: wrap; gap: 0.4rem; }
        .annotation-tag { padding: 3px 10px; border-radius: 20px; font-size: 0.72rem; font-weight: 600; }
        .state-estable  { background: rgba(52,211,153,0.2); color: #34d399; }
        .state-mejoria  { background: rgba(96,165,250,0.2); color: #60a5fa; }
        .state-deterioro{ background: rgba(245,158,11,0.2); color: #f59e0b; }
        .state-crisis   { background: rgba(248,113,113,0.2); color: #f87171; }
    </style>
</head>
<body>
<div class="dashboard">
    <div class="dash-header">
        <h1>Dashboard ClÃ­nico <span>SOLO PROFESIONAL</span></h1>
        <a href="/hdd/admin/" class="back-btn">â† Panel Admin</a>
    </div>
    <div id="content"><div class="loading">Verificando acceso...</div></div>
</div>

<script>
const SB_URL = 'https://yqpqfzvgcmvxvqzvtajx.supabase.co';
const SB_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InlxcHFmenZnY212eHZxenZ0YWp4Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NDk1OTMzODksImV4cCI6MjA2NTE2OTM4OX0.jM2YEBXQ0YFwFOBu3mGbU3NxCez29x8RKYYDV2d8snk';
const sb = window.supabase.createClient(SB_URL, SB_KEY);

const GAMES = {
    'lawn-mower': { name: 'Cortadora de CÃ©sped', icon: 'ğŸŒ¿', color: '#22c55e' },
    'medication-memory': { name: 'Memoria de MedicaciÃ³n', icon: 'ğŸ’Š', color: '#3b82f6' },
    'pill-organizer': { name: 'Organizador de Pastillas', icon: 'ğŸ¯', color: '#f59e0b' },
    'daily-routine': { name: 'Rutina Diaria', icon: 'ğŸ“…', color: '#06b6d4' },
    'fridge-logic': { name: 'LÃ³gica de Heladera', icon: 'ğŸ§Š', color: '#8b5cf6' },
    'super-market': { name: 'Supermercado', icon: 'ğŸ›’', color: '#ec4899' },
    'neuro-chef': { name: 'Neuro-Chef', icon: 'ğŸ‘¨â€ğŸ³', color: '#a855f7' },
    'neuro-chef-v2': { name: 'Neuro-Chef v2', icon: 'ğŸ§ ', color: '#a855f7' }
};

let charts = {};
let currentPatient = null;
let currentDni = null;
let allData = {};
let bioTimeline = [];
let clinicalAnnotations = [];

// Auth check
(async function init() {
    const adminSession = localStorage.getItem('hdd_admin_session');
    if (!adminSession) {
        document.getElementById('content').innerHTML = `
            <div class="auth-gate">
                <h2>Acceso restringido</h2>
                <p>Este dashboard es solo para profesionales autorizados.</p>
                <p style="margin-top:1rem;"><a href="/hdd/admin/">Iniciar sesiÃ³n como administrador</a></p>
            </div>`;
        return;
    }

    // Verify session
    try {
        const res = await fetch('/api/hdd/admin', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ action: 'verify_session', sessionToken: adminSession })
        });
        const d = await res.json();
        if (!d.valid) throw new Error('invalid');
    } catch(e) {
        // Allow if session exists (offline resilience)
        console.warn('Admin verify failed, proceeding with stored session');
    }

    await loadPatients();
})();

async function loadPatients() {
    const { data: patients } = await sb.from('hdd_patients').select('id, full_name, patient_dni, dni, created_at').order('full_name');
    if (!patients || patients.length === 0) {
        document.getElementById('content').innerHTML = '<div class="no-data">No hay pacientes registrados.</div>';
        return;
    }

    let html = `<div class="patient-selector">
        <select id="patientSelect"><option value="">Seleccionar paciente...</option>`;
    patients.forEach(p => {
        html += `<option value="${p.id}">${p.full_name || 'Sin nombre'} â€” DNI: ${p.patient_dni || p.dni || '?'}</option>`;
    });
    html += `</select><span class="patient-info-bar" id="patientInfoBar"></span></div>
        <div id="dashContent"><div class="no-data">SeleccionÃ¡ un paciente para ver su evoluciÃ³n clÃ­nica.</div></div>`;
    document.getElementById('content').innerHTML = html;

    document.getElementById('patientSelect').addEventListener('change', function() {
        if (this.value) loadPatientData(this.value);
    });

    // Auto-select from URL param
    const urlPid = new URLSearchParams(window.location.search).get('patient_id');
    if (urlPid) {
        document.getElementById('patientSelect').value = urlPid;
        loadPatientData(urlPid);
    }
}

async function loadPatientData(pid) {
    currentPatient = pid;
    document.getElementById('dashContent').innerHTML = '<div class="loading">Cargando datos clÃ­nicos...</div>';

    try {
        // 1. Obtener paciente por ID para conseguir su DNI
        const patRes = await sb.from('hdd_patients').select('*').eq('id', pid).single();
        const patient = patRes.data;
        if (!patient) throw new Error('Paciente no encontrado');

        const dni = patient.patient_dni || patient.dni;
        if (!dni) throw new Error('Paciente sin DNI registrado');
        currentDni = dni;

        // 2. Consultar por DNI â€” asÃ­ guardan todos los juegos
        const [metRes, moodRes] = await Promise.all([
            sb.from('hdd_game_metrics')
                .select('*')
                .eq('patient_dni', dni)
                .order('session_date', { ascending: true }),
            sb.from('hdd_mood_entries')
                .select('*')
                .eq('patient_dni', dni)
                .order('recorded_at', { ascending: true })
        ]);

        const metrics = metRes.data || [];
        const moods = moodRes.data || [];

        // Sessions = registros de tipo session_summary (uno por partida)
        const sessions = metrics.filter(m => m.metric_type === 'session_summary' || (!m.metric_type || m.metric_type === 'session'));

        document.getElementById('patientInfoBar').textContent =
            `DNI: ${dni} | Ingreso: ${patient.created_at ? new Date(patient.created_at).toLocaleDateString('es-AR') : '?'} | Registros: ${metrics.length}`;

        // 3. Load lifetime biometric profile via backend API
        await loadBiometricProfile(dni);

        allData = { sessions, metrics, moods, patient, dni };
        renderDashboard(sessions, metrics, moods);
    } catch(e) {
        console.error(e);
        document.getElementById('dashContent').innerHTML = `<div class="no-data">Error cargando datos: ${e.message}</div>`;
    }
}

// â”€â”€ Lifetime biometric profile â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
async function loadBiometricProfile(dni) {
    const adminSession = localStorage.getItem('hdd_admin_session');
    try {
        const res = await fetch('/api/hdd/admin', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ action: 'get_biometric_profile', patient_dni: dni, sessionToken: adminSession })
        });
        const d = await res.json();
        bioTimeline     = d.timeline     || [];
        clinicalAnnotations = d.annotations || [];
    } catch(e) {
        console.warn('Biomet profile load failed:', e);
        bioTimeline = [];
        clinicalAnnotations = [];
    }
}

async function addAnnotation(clinical_state, symptoms_str, notes) {
    const adminSession = localStorage.getItem('hdd_admin_session');
    const symptoms = symptoms_str ? symptoms_str.split(',').map(s => s.trim()).filter(Boolean) : [];
    try {
        await fetch('/api/hdd/admin', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                action: 'add_clinical_annotation',
                patient_dni: currentDni,
                annotation_date: new Date().toISOString().split('T')[0],
                clinical_state, symptoms, notes,
                sessionToken: adminSession
            })
        });
        await loadBiometricProfile(currentDni);
        renderAnnotationList();
    } catch(e) { console.error('Annotation save failed:', e); }
}

function renderAnnotationList() {
    const el = document.getElementById('annotationList');
    if (!el) return;
    if (!clinicalAnnotations.length) {
        el.innerHTML = '<span style="color:rgba(255,255,255,0.3);font-size:0.8rem;">Sin anotaciones clÃ­nicas aÃºn.</span>';
        return;
    }
    el.innerHTML = clinicalAnnotations.slice(-10).reverse().map(a => {
        const cls = 'state-' + (a.clinical_state || 'estable');
        const syms = (a.symptoms || []).join(', ');
        const dt   = new Date(a.annotation_date).toLocaleDateString('es-AR', {day:'2-digit',month:'short',year:'2-digit'});
        return `<span class="annotation-tag ${cls}" title="${syms}${a.notes ? ' â€” '+a.notes : ''}">${dt}: ${a.clinical_state || '?'}${syms ? ' Â· '+syms : ''}</span>`;
    }).join('');
}

// â”€â”€ Main dashboard renderer â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function renderDashboard(sessions, metrics, moods) {
    const dc = document.getElementById('dashContent');
    Object.values(charts).forEach(c => c.destroy());
    charts = {};

    if (metrics.length === 0 && moods.length === 0) {
        dc.innerHTML = '<div class="no-data">Sin datos registrados para este paciente aÃºn.<br><small style="color:rgba(255,255,255,0.3)">Los datos aparecen a medida que el paciente juega y selecciona colores.</small></div>';
        return;
    }

    // Agregados globales desde hdd_game_metrics
    const gameSessions = metrics.filter(m => m.metric_type === 'session_summary');
    const biometSessions = metrics.filter(m => m.metric_type === 'session_biomet');
    const colorEntries = metrics.filter(m => m.metric_type === 'color_eleccion');

    const totalSessions = gameSessions.length;
    const completedSessions = gameSessions.filter(s => s.completed).length;
    const totalTimeSec = gameSessions.reduce((a, s) => a + (s.duration_seconds || 0), 0);
    const totalDays = new Set(gameSessions.map(s => (s.session_date || s.created_at || '').split('T')[0]).filter(Boolean)).size;

    // RT promedio desde biomet
    const rtValues = biometSessions.map(m => m.metric_data?.rt_mean_ms).filter(v => v > 0);
    const avgRT = rtValues.length ? Math.round(rtValues.reduce((a, b) => a + b, 0) / rtValues.length) : 'â€”';

    // Juegos Ãºnicos
    const gamesSlugs = [...new Set(gameSessions.map(s => s.game_slug).filter(Boolean))];

    // â”€â”€ Clinical annotation panel â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    let html = `<div class="annotation-panel">
        <h3>Estado ClÃ­nico â€” Anotaciones Profesionales</h3>
        <div class="annotation-form">
            <select id="annState">
                <option value="">Estado clÃ­nico...</option>
                <option value="estable">Estable</option>
                <option value="mejoria">MejorÃ­a</option>
                <option value="deterioro">Deterioro</option>
                <option value="crisis">Crisis</option>
            </select>
            <input id="annSymptoms" type="text" placeholder="SÃ­ntomas (coma separados): ansiedad, insomnio..." style="min-width:220px;">
            <input id="annNotes" type="text" placeholder="Nota breve (opcional)">
            <button class="annotation-btn" onclick="(function(){addAnnotation(document.getElementById('annState').value, document.getElementById('annSymptoms').value, document.getElementById('annNotes').value);})()">+ Agregar</button>
        </div>
        <div class="annotation-list" id="annotationList"></div>
    </div>`;

    // â”€â”€ Summary cards â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    html += `<div class="summary-row">
        <div class="summary-card"><div class="val">${totalSessions}</div><div class="lbl">Sesiones juego</div></div>
        <div class="summary-card"><div class="val">${completedSessions}</div><div class="lbl">Completadas</div></div>
        <div class="summary-card"><div class="val">${totalDays}</div><div class="lbl">DÃ­as activos</div></div>
        <div class="summary-card"><div class="val">${Math.round(totalTimeSec / 60)}min</div><div class="lbl">Tiempo total</div></div>
        <div class="summary-card"><div class="val">${avgRT}</div><div class="lbl">RT promedio (ms)</div></div>
        <div class="summary-card"><div class="val">${gamesSlugs.length}</div><div class="lbl">Juegos distintos</div></div>
        <div class="summary-card"><div class="val">${moods.length + colorEntries.length}</div><div class="lbl">Registros color</div></div>
        <div class="summary-card"><div class="val">${bioTimeline.length}</div><div class="lbl">Captures lifetime</div></div>
    </div>`;

    // â”€â”€ Biometric profile (radar + login dynamics) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    html += `<div class="section-title">Perfil BiomÃ©trico Longitudinal <small style="color:rgba(255,255,255,0.3);font-size:0.75rem;">â€” desde primer login, de por vida</small></div>
    <div class="profile-grid">
        <div class="chart-box"><h3>Perfil Psicomotor (todos los juegos)</h3><canvas id="chartRadar"></canvas></div>
        <div class="chart-box"><h3>DinÃ¡mica de Teclado en Login (CV inter-tecla â€” variabilidad motora)</h3><canvas id="chartLoginBiomet"></canvas></div>
    </div>`;

    // â”€â”€ Neurocognitive domain panel â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    html += `<div class="section-title">Dominios Neurocognitivos <small style="color:rgba(255,255,255,0.3);font-size:0.75rem;">â€” Ãºltimas sesiones disponibles</small></div>
    <div class="domain-grid" id="domainGrid">
        <div class="domain-card" id="dom-atencion">
            <div class="domain-card-header"><span class="domain-icon">ğŸ¯</span><span class="domain-name">AtenciÃ³n</span></div>
            <div class="domain-metrics" id="dm-atencion"><span class="domain-no-data">Sin datos</span></div>
        </div>
        <div class="domain-card" id="dom-memoria">
            <div class="domain-card-header"><span class="domain-icon">ğŸ§ </span><span class="domain-name">Memoria</span></div>
            <div class="domain-metrics" id="dm-memoria"><span class="domain-no-data">Sin datos</span></div>
        </div>
        <div class="domain-card" id="dom-ejecutivo">
            <div class="domain-card-header"><span class="domain-icon">âš™ï¸</span><span class="domain-name">Funciones Ejecutivas</span></div>
            <div class="domain-metrics" id="dm-ejecutivo"><span class="domain-no-data">Sin datos</span></div>
        </div>
        <div class="domain-card" id="dom-psicomotor">
            <div class="domain-card-header"><span class="domain-icon">âœ‹</span><span class="domain-name">Psicomotricidad</span></div>
            <div class="domain-metrics" id="dm-psicomotor"><span class="domain-no-data">Sin datos</span></div>
        </div>
        <div class="domain-card" id="dom-visuoespacial">
            <div class="domain-card-header"><span class="domain-icon">ğŸ‘ï¸</span><span class="domain-name">Visuoespacial</span></div>
            <div class="domain-metrics" id="dm-visuoespacial"><span class="domain-no-data">Sin datos</span></div>
        </div>
        <div class="domain-card" id="dom-subjetividad">
            <div class="domain-card-header"><span class="domain-icon">ğŸª</span><span class="domain-name">Subjetividad</span></div>
            <div class="domain-metrics" id="dm-subjetividad"><span class="domain-no-data">Sin datos</span></div>
        </div>
    </div>`;

    // â”€â”€ Timeline de colores â€” combina hdd_mood_entries + color_eleccion en hdd_game_metrics
    const allColors = [
        ...moods.map(m => ({ hex: m.color_hex, id: m.color_id, date: m.recorded_at || m.created_at, ctx: m.context_type || 'game' })),
        ...colorEntries.map(m => ({ hex: m.metric_data?.color_hex, id: m.metric_data?.color_id, date: m.session_date || m.created_at, ctx: m.metric_data?.context_type || m.game_slug }))
    ].filter(c => c.hex).sort((a, b) => new Date(a.date) - new Date(b.date));

    if (allColors.length > 0) {
        html += `<div class="section-title">Colores seleccionados (lÃ­nea temporal â€” ${allColors.length} registros)</div><div class="mood-timeline">`;
        allColors.forEach(c => {
            const d = new Date(c.date).toLocaleDateString('es-AR', { day:'2-digit', month:'short' });
            html += `<div class="mood-dot" style="background:${c.hex}"><div class="tooltip">${d} â€” ${c.ctx}</div></div>`;
        });
        html += `</div>`;
    } else {
        html += `<div class="section-title">Colores seleccionados</div><div class="no-data" style="padding:1rem;">Sin registros de color aÃºn.</div>`;
    }

    // Charts area
    html += `<div class="section-title">EvoluciÃ³n Longitudinal</div>`;
    html += `<div class="charts-grid">
        <div class="chart-box"><h3>Tiempo de ReacciÃ³n (ms)</h3><canvas id="chartRT"></canvas></div>
        <div class="chart-box"><h3>Puntaje por sesiÃ³n</h3><canvas id="chartScore"></canvas></div>
        <div class="chart-box"><h3>Errores (omisiÃ³n vs comisiÃ³n)</h3><canvas id="chartErrors"></canvas></div>
        <div class="chart-box full"><h3>Tremor / Hesitaciones</h3><canvas id="chartTremor"></canvas></div>
    </div>`;

    // Tabla de sesiones
    html += `<div class="section-title">Historial de Sesiones (${totalSessions} registros)</div>
    <div style="overflow-x:auto;">
    <table class="sessions-table">
        <thead><tr>
            <th>Fecha</th><th>Juego</th><th>Nivel</th><th>Puntaje</th><th>DuraciÃ³n</th><th>RT (ms)</th><th>Omisiones</th><th>Comisiones</th><th>Completado</th>
        </tr></thead><tbody>`;

    const rows = gameSessions.slice().reverse().map(s => {
        const game = GAMES[s.game_slug] || { name: s.game_slug || 'juego', icon: 'ğŸ®' };
        const dt = (s.session_date || s.created_at) ? new Date(s.session_date || s.created_at).toLocaleDateString('es-AR', { day:'2-digit', month:'short', year:'2-digit' }) : '?';
        // Buscar biomet correspondiente a esta sesiÃ³n
        const bio = biometSessions.find(b => b.game_slug === s.game_slug && Math.abs(new Date(b.session_date||b.created_at) - new Date(s.session_date||s.created_at)) < 60000);
        const bd = bio?.metric_data || {};
        return `<tr>
            <td>${dt}</td>
            <td>${game.icon} ${game.name}</td>
            <td>${s.level_reached ?? 'â€”'}</td>
            <td>${s.score ?? s.metric_value ?? 0}</td>
            <td>${s.duration_seconds ? Math.round(s.duration_seconds) + 's' : 'â€”'}</td>
            <td>${bd.rt_mean_ms ? Math.round(bd.rt_mean_ms) : 'â€”'}</td>
            <td>${bd.errores_omision ?? 'â€”'}</td>
            <td>${bd.errores_comision ?? 'â€”'}</td>
            <td>${s.completed ? 'âœ“' : 'âœ—'}</td>
        </tr>`;
    });

    html += rows.join('') || '<tr><td colspan="9" style="text-align:center;color:rgba(255,255,255,0.3);padding:2rem;">Sin sesiones registradas</td></tr>';
    html += `</tbody></table></div>`;

    dc.innerHTML = html;
    requestAnimationFrame(() => renderCharts(gameSessions, biometSessions, allColors));
}

function getGameSlug(session) {
    return session.game_slug || 'unknown';
}

function renderCharts(gameSessions, biometSessions, allColors) {
    const chartOpts = {
        responsive: true,
        plugins: { legend: { display: true, labels: { color: 'rgba(255,255,255,0.5)', font: { size: 10 } } } },
        scales: {
            x: { ticks: { color: 'rgba(255,255,255,0.3)', font: { size: 9 } }, grid: { color: 'rgba(255,255,255,0.04)' } },
            y: { ticks: { color: 'rgba(255,255,255,0.3)', font: { size: 9 } }, grid: { color: 'rgba(255,255,255,0.06)' } }
        }
    };

    // RT chart: de biomet sessions
    const rtData = biometSessions.filter(m => m.metric_data?.rt_mean_ms > 0).sort((a, b) => new Date(a.session_date||a.created_at) - new Date(b.session_date||b.created_at));
    if (rtData.length > 0) {
        const byGame = {};
        rtData.forEach(m => {
            const slug = m.game_slug || 'unknown';
            if (!byGame[slug]) byGame[slug] = [];
            byGame[slug].push({ date: m.session_date || m.created_at, rt: m.metric_data.rt_mean_ms });
        });
        const allDates = [...new Set(rtData.map(m => (m.session_date||m.created_at).split('T')[0]))].sort();
        const datasets = Object.entries(byGame).map(([slug, pts]) => {
            const game = GAMES[slug] || { name: slug, color: '#6b7280' };
            return {
                label: game.name || slug,
                data: allDates.map(d => { const p = pts.find(x => (x.date||'').startsWith(d)); return p ? p.rt : null; }),
                borderColor: game.color || '#60a5fa', tension: 0.3, spanGaps: true, pointRadius: 4
            };
        });
        charts.rt = new Chart(document.getElementById('chartRT'), {
            type: 'line',
            data: { labels: allDates, datasets },
            options: chartOpts
        });
    }

    // Score chart
    const scoreSessions = gameSessions.filter(s => (s.score ?? s.metric_value) > 0).sort((a, b) => new Date(a.session_date||a.created_at) - new Date(b.session_date||b.created_at));
    if (scoreSessions.length > 0) {
        charts.score = new Chart(document.getElementById('chartScore'), {
            type: 'bar',
            data: {
                labels: scoreSessions.map(s => new Date(s.session_date||s.created_at).toLocaleDateString('es-AR', { day:'2-digit', month:'short' })),
                datasets: [{ label: 'Puntaje', data: scoreSessions.map(s => s.score ?? s.metric_value ?? 0),
                    backgroundColor: scoreSessions.map(s => GAMES[s.game_slug]?.color || '#6b7280'), borderRadius: 4 }]
            },
            options: { ...chartOpts, plugins: { ...chartOpts.plugins, legend: { display: false } } }
        });
    }

    // Errors chart: omisiones y comisiones desde biomet
    const errData = biometSessions.filter(m => m.metric_data?.errores_omision != null || m.metric_data?.errores_comision != null).sort((a, b) => new Date(a.session_date||a.created_at) - new Date(b.session_date||b.created_at));
    if (errData.length > 0) {
        charts.errors = new Chart(document.getElementById('chartErrors'), {
            type: 'bar',
            data: {
                labels: errData.map(m => new Date(m.session_date||m.created_at).toLocaleDateString('es-AR', { day:'2-digit', month:'short' })),
                datasets: [
                    { label: 'Omisiones', data: errData.map(m => m.metric_data.errores_omision || 0), backgroundColor: 'rgba(239,68,68,0.7)', borderRadius: 3 },
                    { label: 'Comisiones', data: errData.map(m => m.metric_data.errores_comision || 0), backgroundColor: 'rgba(245,158,11,0.7)', borderRadius: 3 }
                ]
            },
            options: chartOpts
        });
    }

    // Tremor / Hesitaciones chart desde biomet
    const tremorData = biometSessions.filter(m => m.metric_data?.tremor_reposo_px != null).sort((a, b) => new Date(a.session_date||a.created_at) - new Date(b.session_date||b.created_at));
    if (tremorData.length > 0) {
        charts.tremor = new Chart(document.getElementById('chartTremor'), {
            type: 'line',
            data: {
                labels: tremorData.map(m => new Date(m.session_date||m.created_at).toLocaleDateString('es-AR', { day:'2-digit', month:'short' })),
                datasets: [
                    { label: 'Tremor reposo (px)', data: tremorData.map(m => m.metric_data.tremor_reposo_px || 0), borderColor: '#f87171', tension: 0.3, yAxisID: 'y' },
                    { label: 'Hesitaciones', data: tremorData.map(m => m.metric_data.hesitaciones_count || 0), borderColor: '#fbbf24', tension: 0.3, yAxisID: 'y1' }
                ]
            },
            options: {
                ...chartOpts,
                scales: {
                    ...chartOpts.scales,
                    y: { ...chartOpts.scales.y, position: 'left', title: { display: true, text: 'Tremor px', color: 'rgba(255,255,255,0.3)' } },
                    y1: { ticks: { color: 'rgba(255,255,255,0.3)' }, grid: { drawOnChartArea: false }, position: 'right', title: { display: true, text: 'Hesitaciones', color: 'rgba(255,255,255,0.3)' } }
                }
            }
        });
    }

    // â”€â”€ Radar: Perfil BiomÃ©trico (agregado lifetime desde hdd_biometric_timeline) â”€â”€
    // All game captures from bioTimeline with game context
    const gameCaptures = bioTimeline.filter(b => b.capture_context === 'game' && b.biomet_data);
    if (gameCaptures.length > 0 && document.getElementById('chartRadar')) {
        const avg = (key) => {
            const vals = gameCaptures.map(b => Number(b.biomet_data[key])).filter(v => !isNaN(v) && v > 0);
            return vals.length ? vals.reduce((a, b) => a + b, 0) / vals.length : 0;
        };
        // Normalize to 0-100 scale for radar readability
        const rtAvg      = avg('rt_mean_ms');
        const tremorAvg  = avg('tremor_reposo_px');
        const omisAvg    = avg('errores_omision');
        const comisAvg   = avg('errores_comision');
        const eficAvg    = avg('eficiencia_trayectoria');
        const impulsAvg  = avg('impulsividad_ratio');

        // Normalize: RT > 0 ? map to 0-100 (lower is better, so invert)
        const normalize = (val, max, invert=false) => {
            const n = Math.min((val / max) * 100, 100);
            return invert ? 100 - n : n;
        };

        charts.radar = new Chart(document.getElementById('chartRadar'), {
            type: 'radar',
            data: {
                labels: ['Velocidad RT', 'PrecisiÃ³n\n(sin tremor)', 'Completitud\n(sin omisiones)', 'Control\n(sin comisiones)', 'Eficiencia\ntrayectoria', 'Control\nimpulsos'],
                datasets: [{
                    label: 'Perfil actual',
                    data: [
                        normalize(rtAvg, 1000, true),         // RT â€” lower is better
                        normalize(tremorAvg, 20, true),        // tremor â€” lower is better
                        normalize(omisAvg, 10, true),          // omissions â€” lower is better
                        normalize(comisAvg, 10, true),         // commissions â€” lower is better
                        normalize(eficAvg, 1, false) * 100,    // efficiency 0-1 â†’ 0-100
                        normalize(impulsAvg, 0.5, true)        // impulsivity â€” lower is better
                    ],
                    backgroundColor: 'rgba(96,165,250,0.15)',
                    borderColor: '#60a5fa',
                    pointBackgroundColor: '#60a5fa',
                    pointRadius: 4
                }]
            },
            options: {
                responsive: true,
                plugins: { legend: { display: false } },
                scales: {
                    r: {
                        min: 0, max: 100,
                        ticks: { display: false },
                        grid: { color: 'rgba(255,255,255,0.08)' },
                        pointLabels: { color: 'rgba(255,255,255,0.5)', font: { size: 9 } },
                        angleLines: { color: 'rgba(255,255,255,0.06)' }
                    }
                }
            }
        });
    }

    // â”€â”€ Login biometric trend: keyboard CV over time â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    const loginCaptures = bioTimeline
        .filter(b => b.capture_context === 'login' && b.biomet_data?.ik_cv != null)
        .sort((a, b) => new Date(a.captured_at) - new Date(b.captured_at));

    if (loginCaptures.length > 0 && document.getElementById('chartLoginBiomet')) {
        // Build annotation overlay (colored background by clinical state)
        const annotationByDate = {};
        clinicalAnnotations.forEach(a => { annotationByDate[a.annotation_date] = a.clinical_state; });
        const stateColors = { estable: '#34d399', mejoria: '#60a5fa', deterioro: '#f59e0b', crisis: '#f87171' };

        const loginLabels = loginCaptures.map(b => new Date(b.captured_at).toLocaleDateString('es-AR', {day:'2-digit',month:'short',year:'2-digit'}));
        const loginCVs    = loginCaptures.map(b => b.biomet_data.ik_cv);
        const bgColors    = loginCaptures.map(b => {
            const dateStr = b.captured_at.split('T')[0];
            const state   = annotationByDate[dateStr];
            return state ? stateColors[state] + '33' : 'transparent';
        });

        charts.loginBiomet = new Chart(document.getElementById('chartLoginBiomet'), {
            type: 'line',
            data: {
                labels: loginLabels,
                datasets: [{
                    label: 'CV inter-tecla (variabilidad motora login)',
                    data: loginCVs,
                    borderColor: '#a78bfa',
                    backgroundColor: 'rgba(167,139,250,0.1)',
                    fill: true,
                    tension: 0.4,
                    pointBackgroundColor: loginCaptures.map(b => {
                        const state = annotationByDate[b.captured_at.split('T')[0]];
                        return state ? stateColors[state] : '#a78bfa';
                    }),
                    pointRadius: 5
                }]
            },
            options: {
                ...chartOpts,
                plugins: {
                    ...chartOpts.plugins,
                    tooltip: {
                        callbacks: {
                            afterLabel: function(ctx) {
                                const b = loginCaptures[ctx.dataIndex];
                                const state = annotationByDate[b.captured_at.split('T')[0]];
                                const lines = [`Teclas: ${b.biomet_data.keypress_count || '?'}`, `Tiempo total: ${b.biomet_data.total_ms || '?'}ms`];
                                if (state) lines.push(`Estado clÃ­nico: ${state}`);
                                return lines;
                            }
                        }
                    }
                }
            }
        });
    }

    // â”€â”€ Populate neurocognitive domain cards â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    function domMetric(lbl, val, unit, thresholds) {
        // thresholds: { good: fn, bad: fn } â€” evaluated against val
        let cls = '';
        if (val !== null && val !== undefined && !isNaN(val)) {
            if (thresholds?.good && thresholds.good(val)) cls = 'good';
            else if (thresholds?.bad && thresholds.bad(val)) cls = 'bad';
            else cls = 'warn';
        }
        const display = (val !== null && val !== undefined && !isNaN(val))
            ? String(typeof val === 'number' ? (Number.isInteger(val) ? val : val.toFixed(2)) : val) + (unit || '')
            : 'â€”';
        return `<div class="domain-metric-row">
            <span class="domain-metric-lbl">${lbl}</span>
            <span class="domain-metric-val ${cls}">${display}</span></div>`;
    }

    function avg(arr, key) {
        const vals = arr.map(m => Number(m?.metric_data?.[key])).filter(v => !isNaN(v) && v !== 0);
        return vals.length ? vals.reduce((a, b) => a + b, 0) / vals.length : null;
    }

    const recent5 = biometSessions.slice(-5);

    // AtenciÃ³n
    const rtA = avg(recent5, 'rt_mean_ms');
    const cvA = avg(recent5, 'rt_cv');
    const decA = avg(recent5, 'decaimiento_vigilancia');
    const hesA = avg(recent5, 'hesitaciones_count');
    if (rtA !== null || cvA !== null) {
        document.getElementById('dm-atencion').innerHTML =
            domMetric('RT promedio', rtA, ' ms', { good: v => v < 600, bad: v => v > 1500 }) +
            domMetric('CV atenciÃ³n', cvA, '', { good: v => v < 0.3, bad: v => v > 0.6 }) +
            domMetric('Decaimiento vigilancia', decA, '', { good: v => v < 1.2, bad: v => v > 1.8 }) +
            domMetric('Hesitaciones (n)', hesA, '', { good: v => v <= 1, bad: v => v > 5 });
    }

    // Memoria â€” from medication-memory game sessions
    const memSessions = gameSessions.filter(s => (s.game_slug || '').includes('medication'));
    const routineSessions = gameSessions.filter(s => (s.game_slug || '').includes('daily-routine'));
    const memSpanVals = memSessions.map(s => s.metric_data?.clinical_markers?.memory_span || s.metric_data?.memory_span).filter(v => v != null && !isNaN(v));
    const primacyVals = memSessions.map(s => s.metric_data?.clinical_markers?.efecto_primacia).filter(v => v != null && !isNaN(v));
    const recenciaVals = memSessions.map(s => s.metric_data?.clinical_markers?.efecto_recencia).filter(v => v != null && !isNaN(v));
    const divHabVals  = routineSessions.map(s => s.metric_data?.diversidad_habitos).filter(v => v != null && !isNaN(v));
    const msMean = memSpanVals.length ? memSpanVals.slice(-3).reduce((a,b)=>a+b,0)/Math.min(3, memSpanVals.length) : null;
    const primMean = primacyVals.length ? primacyVals.slice(-3).reduce((a,b)=>a+b,0)/Math.min(3, primacyVals.length) : null;
    const recMean = recenciaVals.length ? recenciaVals.slice(-3).reduce((a,b)=>a+b,0)/Math.min(3, recenciaVals.length) : null;
    const divHabMean = divHabVals.length ? divHabVals.slice(-3).reduce((a,b)=>a+b,0)/Math.min(3, divHabVals.length) : null;
    if (msMean !== null || divHabMean !== null) {
        document.getElementById('dm-memoria').innerHTML =
            domMetric('Memory span (items)', msMean, '', { good: v => v >= 3, bad: v => v < 2 }) +
            domMetric('Efecto primacÃ­a', primMean, '', { good: v => v >= 0.7, bad: v => v < 0.4 }) +
            domMetric('Efecto recencia', recMean, '', { good: v => v >= 0.7, bad: v => v < 0.4 }) +
            domMetric('Diversidad hÃ¡bitos', divHabMean, '/3', { good: v => v >= 3, bad: v => v < 2 });
    }

    // Funciones Ejecutivas
    const ecoA  = avg(recent5, 'economia_cognitiva');
    const impA  = avg(recent5, 'impulsividad_ratio');
    const inhA  = avg(recent5, 'inhibicion_motor');
    const persA = avg(recent5, 'perseveracion_count');
    if (ecoA !== null || impA !== null) {
        document.getElementById('dm-ejecutivo').innerHTML =
            domMetric('EconomÃ­a cognitiva', ecoA, '', { good: v => v >= 0.8, bad: v => v < 0.5 }) +
            domMetric('Impulsividad', impA, '', { good: v => v < 0.1, bad: v => v > 0.3 }) +
            domMetric('InhibiciÃ³n motora', inhA, '', { good: v => v < 0.1, bad: v => v > 0.25 }) +
            domMetric('Perseveraciones', persA, '', { good: v => v === 0, bad: v => v > 3 });
    }

    // Psicomotricidad
    const trRep = avg(recent5, 'tremor_reposo_px');
    const trAcc = avg(recent5, 'tremor_accion_px');
    const trDis = avg(recent5, 'tremor_distal_px');
    const efTr  = avg(recent5, 'eficiencia_trayectoria');
    if (trRep !== null || trAcc !== null) {
        document.getElementById('dm-psicomotor').innerHTML =
            domMetric('Tremor reposo (px)', trRep, '', { good: v => v < 1, bad: v => v > 3 }) +
            domMetric('Tremor acciÃ³n (px)', trAcc, '', { good: v => v < 1.5, bad: v => v > 4 }) +
            domMetric('Tremor distal (px)', trDis, '', { good: v => v < 2, bad: v => v > 5 }) +
            domMetric('Eficiencia trayectoria', efTr, '', { good: v => v >= 0.85, bad: v => v < 0.6 });
    }

    // Visuoespacial
    const seqA  = avg(recent5, 'secuencia_correcta_pct');
    const recA  = avg(recent5, 'rectificaciones_count');
    const disA  = avg(recent5, 'dismetria_mean_px');
    if (seqA !== null || recA !== null) {
        document.getElementById('dm-visuoespacial').innerHTML =
            domMetric('Secuencia correcta', seqA, '', { good: v => v >= 0.85, bad: v => v < 0.5 }) +
            domMetric('Rectificaciones (n)', recA, '', { good: v => v <= 2, bad: v => v > 8 }) +
            domMetric('DismetrÃ­a (px)', disA, '', { good: v => v < 30, bad: v => v > 80 }) +
            domMetric('Eficiencia tray.', efTr, '', { good: v => v >= 0.85, bad: v => v < 0.6 });
    }

    // Subjetividad â€” daily-routine specific
    const animoVals = routineSessions.map(s => s.metric_data?.estado_animo_proxy).filter(v => v != null && !isNaN(v));
    const saludVals = routineSessions.map(s => s.metric_data?.habitos_salud_ratio).filter(v => v != null && !isNaN(v));
    const socVals   = routineSessions.map(s => s.metric_data?.habitos_sociales_count).filter(v => v != null && !isNaN(v));
    const autoVals  = routineSessions.map(s => s.metric_data?.autoexigencia_score).filter(v => v != null && !isNaN(v));
    const animoMean = animoVals.length ? animoVals.slice(-3).reduce((a,b)=>a+b,0)/Math.min(3, animoVals.length) : null;
    const saludMean = saludVals.length ? saludVals.slice(-3).reduce((a,b)=>a+b,0)/Math.min(3, saludVals.length) : null;
    const socMean   = socVals.length ? socVals.slice(-3).reduce((a,b)=>a+b,0)/Math.min(3, socVals.length) : null;
    const autoMean  = autoVals.length ? autoVals.slice(-3).reduce((a,b)=>a+b,0)/Math.min(3, autoVals.length) : null;
    if (animoMean !== null || saludMean !== null) {
        document.getElementById('dm-subjetividad').innerHTML =
            domMetric('Estado Ã¡nimo (proxy)', animoMean, '/5', { good: v => v >= 4, bad: v => v <= 2 }) +
            domMetric('HÃ¡bitos salud', saludMean, '', { good: v => v >= 0.8, bad: v => v < 0.5 }) +
            domMetric('HÃ¡bitos sociales (n)', socMean, '', { good: v => v >= 1, bad: v => v === 0 }) +
            domMetric('Autoexigencia', autoMean, '', { good: v => v >= 0.7, bad: v => v < 0.3 });
    }

    // Render annotation list after charts are built
    renderAnnotationList();
}
</script>
</body>
</html>
